# name: test/sql/parse_duck_hunt_log.test
# description: test parse_duck_hunt_log function with various formats
# group: [sql]

require duck_hunt

# Test 1: ESLint JSON format parsing
statement ok
CREATE TABLE eslint_results AS 
SELECT * FROM parse_duck_hunt_log('[
  {
    "filePath": "/src/components/Button.js",
    "messages": [
      {
        "ruleId": "no-unused-vars",
        "severity": 2,
        "message": "React is defined but never used.",
        "line": 1,
        "column": 8,
        "nodeType": "Identifier",
        "messageId": "unusedVar"
      },
      {
        "ruleId": "prefer-const",
        "severity": 1,
        "message": "value is never reassigned. Use const instead of let.",
        "line": 5,
        "column": 5,
        "nodeType": "Identifier",
        "messageId": "useConst"
      }
    ]
  }
]', 'eslint_json');

# Verify ESLint parsing results
query IIII
SELECT COUNT(*), tool_name, 
       COUNT(CASE WHEN status = 'ERROR' THEN 1 END) as errors,
       COUNT(CASE WHEN status = 'WARNING' THEN 1 END) as warnings
FROM eslint_results
GROUP BY tool_name;
----
2	eslint	1	1

# Test 2: Go test JSON format parsing
statement ok
CREATE TABLE gotest_results AS 
SELECT * FROM parse_duck_hunt_log('{"Time":"2024-07-11T00:50:12.123456789Z","Action":"run","Package":"github.com/example/project","Test":"TestCalculator"}
{"Time":"2024-07-11T00:50:12.124567890Z","Action":"fail","Package":"github.com/example/project","Test":"TestCalculator","Elapsed":0.003}
{"Time":"2024-07-11T00:50:12.125678901Z","Action":"run","Package":"github.com/example/project","Test":"TestStringUtils"}
{"Time":"2024-07-11T00:50:12.126789012Z","Action":"pass","Package":"github.com/example/project","Test":"TestStringUtils","Elapsed":0.001}
{"Time":"2024-07-11T00:50:12.127890123Z","Action":"run","Package":"github.com/example/project","Test":"TestSkippedTest"}
{"Time":"2024-07-11T00:50:12.128901234Z","Action":"skip","Package":"github.com/example/project","Test":"TestSkippedTest","Elapsed":0.002}', 'gotest_json');

# Verify Go test parsing results
query IIII
SELECT COUNT(*), tool_name,
       COUNT(CASE WHEN status = 'FAIL' THEN 1 END) as fails,
       COUNT(CASE WHEN status = 'PASS' THEN 1 END) as passes
FROM gotest_results
GROUP BY tool_name;
----
3	go_test	1	1

# Test 3: Generic lint format parsing
statement ok
CREATE TABLE lint_results AS 
SELECT * FROM parse_duck_hunt_log('src/main.c:15:5: error: undeclared_var undeclared (first use in this function)
src/main.c:20:12: warning: unused variable temp [-Wunused-variable]
src/utils.c:8:9: error: assignment to expression with array type', 'generic_lint');

# Verify generic lint parsing results
query IIII
SELECT COUNT(*), tool_name,
       COUNT(CASE WHEN status = 'ERROR' THEN 1 END) as errors,
       COUNT(CASE WHEN status = 'WARNING' THEN 1 END) as warnings
FROM lint_results
GROUP BY tool_name;
----
3	lint	2	1

# Test 4: Make error format parsing
statement ok
CREATE TABLE make_results AS 
SELECT * FROM parse_duck_hunt_log('gcc -Wall -Wextra -g -o build/main src/main.c src/utils.c
src/main.c:15:5: error: undeclared_var undeclared
src/utils.c:8:9: error: assignment to expression with array type
make: *** [Makefile:23: build/main] Error 1', 'make_error');

# Verify make error parsing results
query III
SELECT COUNT(*), tool_name,
       COUNT(CASE WHEN status = 'ERROR' THEN 1 END) as errors
FROM make_results
GROUP BY tool_name;
----
3	make	3

# Test 5: Auto-detection capability
query II
SELECT tool_name, COUNT(*) as event_count
FROM parse_duck_hunt_log('[{"filePath":"/test.js","messages":[{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":3,"column":3}]}]', 'auto')
GROUP BY tool_name;
----
eslint	1

# Test 6: ValidationEvent schema completeness
query I
SELECT COUNT(*) FROM (
  SELECT event_id, tool_name, event_type, file_path, line_number, 
         column_number, function_name, status, severity, category, 
         message, suggestion, error_code, test_name, execution_time, 
         raw_output, structured_data
  FROM parse_duck_hunt_log('src/test.c:1:1: error: test message', 'generic_lint')
);
----
1

# Test 7: Edge cases - empty input
query I
SELECT COUNT(*) FROM parse_duck_hunt_log('', 'auto');
----
0

# Test 8: Edge cases - invalid JSON
query I
SELECT COUNT(*) FROM parse_duck_hunt_log('invalid json content}', 'auto');
----
0

# Test 9: Edge cases - unknown format should throw error
statement error
SELECT COUNT(*) FROM parse_duck_hunt_log('random text content', 'unknown');
----
Unknown format

# Test 10: Field validation tests
query IIIIII
SELECT file_path, line_number, column_number, status, severity, error_code
FROM parse_duck_hunt_log('[{"filePath":"/src/Button.js","messages":[{"ruleId":"no-unused-vars","severity":2,"message":"React is defined but never used.","line":1,"column":8}]}]', 'eslint_json');
----
/src/Button.js	1	8	ERROR	error	no-unused-vars

# ====================================================================
# Regexp Parser Tests - Dynamic pattern matching with named groups
# ====================================================================

# Test 11: Basic regexp parsing with severity and message
statement ok
CREATE TABLE regexp_basic AS
SELECT * FROM parse_duck_hunt_log('ERROR: Something went wrong
WARNING: This might be a problem
INFO: Just an update
ERROR: Another error occurred', 'regexp:(?P<severity>ERROR|WARNING|INFO):\s+(?P<message>.+)');

query IIII
SELECT COUNT(*), tool_name,
       COUNT(CASE WHEN status = 'ERROR' THEN 1 END) as errors,
       COUNT(CASE WHEN status = 'WARNING' THEN 1 END) as warnings
FROM regexp_basic
GROUP BY tool_name;
----
4	regexp	2	1

# Test 12: Regexp with file, line, and message (GCC-style)
statement ok
CREATE TABLE regexp_gcc AS
SELECT * FROM parse_duck_hunt_log('src/main.c:42: error: undefined reference
src/utils.c:15: warning: implicit declaration
include/header.h:7: note: see previous declaration', 'regexp:(?P<file>[^:]+):(?P<line>\d+):\s+(?P<severity>error|warning|note):\s+(?P<message>.+)');

query III
SELECT COUNT(*),
       COUNT(CASE WHEN status = 'ERROR' THEN 1 END) as errors,
       COUNT(CASE WHEN status = 'WARNING' THEN 1 END) as warnings
FROM regexp_gcc;
----
3	1	1

# Verify file path and line extraction
query ITI
SELECT file_path, line_number, message
FROM regexp_gcc
WHERE status = 'ERROR';
----
src/main.c	42	undefined reference

# Test 13: Regexp with error code extraction
statement ok
CREATE TABLE regexp_codes AS
SELECT * FROM parse_duck_hunt_log('[E001] Missing semicolon at line 10
[W002] Unused variable foo
[E003] Type mismatch in assignment', 'regexp:\[(?P<code>[EW]\d+)\]\s+(?P<message>.+)');

query ITT
SELECT error_code, message, severity
FROM regexp_codes
ORDER BY error_code;
----
E001	Missing semicolon at line 10	warning
E003	Type mismatch in assignment	warning
W002	Unused variable foo	warning

# Test 14: No matches returns summary event
query ITT
SELECT COUNT(*), category, message
FROM parse_duck_hunt_log('This content has no matching patterns
Just some random text
Nothing to see here', 'regexp:NEVER_MATCH_PATTERN_XYZ')
GROUP BY category, message;
----
1	regexp_summary	No matches found for the provided pattern

# Test 15: Regexp with column number
statement ok
CREATE TABLE regexp_columns AS
SELECT * FROM parse_duck_hunt_log('file.py:10:5: E501 line too long (120 > 79)
file.py:20:1: W293 blank line contains whitespace', 'regexp:(?P<file>[^:]+):(?P<line>\d+):(?P<column>\d+):\s+(?P<code>\w+)\s+(?P<message>.+)');

query TIIII
SELECT file_path, line_number, column_number, error_code, message
FROM regexp_columns
ORDER BY line_number;
----
file.py	10	5	E501	line too long (120 > 79)
file.py	20	1	W293	blank line contains whitespace

# Test 16: Regexp with test name extraction
query TT
SELECT test_name, message
FROM parse_duck_hunt_log('FAIL test_authentication: Expected 200 but got 401
PASS test_user_creation: All assertions passed
FAIL test_data_validation: Invalid data format', 'regexp:(?P<severity>FAIL|PASS)\s+(?P<test_name>\w+):\s+(?P<message>.+)')
WHERE status = 'ERROR';
----
test_authentication	Expected 200 but got 401
test_data_validation	Invalid data format

# Test 17: Python-style named groups (?P<name>)
query II
SELECT COUNT(*), COUNT(CASE WHEN severity = 'error' THEN 1 END) as errors
FROM parse_duck_hunt_log('myapp.ERROR.main: Database connection failed
myapp.WARNING.auth: Token expired
myapp.ERROR.api: Request timeout', 'regexp:myapp\.(?P<severity>ERROR|WARNING)\.(?P<category>\w+):\s+(?P<message>.+)');
----
3	2

# Clean up regexp test tables
statement ok
DROP TABLE regexp_basic;

statement ok
DROP TABLE regexp_gcc;

statement ok
DROP TABLE regexp_codes;

statement ok
DROP TABLE regexp_columns;

# ====================================================================
# Original Cleanup
# ====================================================================

# Clean up
statement ok
DROP TABLE eslint_results;

statement ok
DROP TABLE gotest_results;

statement ok
DROP TABLE lint_results;

statement ok
DROP TABLE make_results;