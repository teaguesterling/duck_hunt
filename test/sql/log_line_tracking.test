# name: test/sql/log_line_tracking.test
# description: test log_line_start and log_line_end fields for tracking position in log files
# group: [sql]

require duck_hunt

# Test 1: make_error parser should populate log line tracking fields
query IIIT
SELECT log_line_start, log_line_end, line_number, message
FROM read_duck_hunt_log('test/samples/make.out', 'make_error')
WHERE log_line_start IS NOT NULL
ORDER BY log_line_start
LIMIT 5;
----
2	2	15	'undefined_var' undeclared (first use in this function)
5	5	15	each undeclared identifier is reported only once for each function it appears in
6	6	28	unused variable 'temp' [-Wunused-variable]
10	10	8	assignment to expression with array type
13	13	NULL	make: *** [Makefile:23: build/main.o] Error 1

# Test 2: Single-line events should have log_line_start == log_line_end
query I
SELECT COUNT(*)
FROM read_duck_hunt_log('test/samples/make.out', 'make_error')
WHERE log_line_start IS NOT NULL AND log_line_start = log_line_end;
----
5

# Test 3: JSON formats should have NULL log line tracking (no meaningful line position)
query II
SELECT log_line_start, log_line_end
FROM read_duck_hunt_log('test/samples/pytest.json', 'pytest_json')
LIMIT 1;
----
NULL	NULL

# Test 4: log_line_start should be 1-indexed (first line is 1, not 0)
query I
SELECT MIN(log_line_start)
FROM read_duck_hunt_log('test/samples/make.out', 'make_error')
WHERE log_line_start IS NOT NULL;
----
2

# Test 5: Verify log_line_start != line_number (they track different things)
# line_number is the source code line, log_line_start is the log file line
query III
SELECT log_line_start, line_number,
       CASE WHEN log_line_start != line_number OR line_number IS NULL THEN 1 ELSE 0 END as different
FROM read_duck_hunt_log('test/samples/make.out', 'make_error')
WHERE log_line_start IS NOT NULL
ORDER BY log_line_start
LIMIT 3;
----
2	15	1
5	15	1
6	28	1
