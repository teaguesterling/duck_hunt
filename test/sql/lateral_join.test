# name: test/sql/lateral_join.test
# description: Minimal lateral join test
# group: [sql]

require duck_hunt

# =============================================================================
# LATERAL format parameter bug fix verification
# The format parameter must be respected in LATERAL joins, not ignored
# =============================================================================

# Test that explicit format is respected in LATERAL joins
# gcc_text should reject .py files (returns 0 rows)
# If format is ignored, auto-detection would use mypy_text (returns 4 rows)
statement ok
CREATE TABLE format_test AS SELECT 'test/samples/mypy.txt' as path;

query I
SELECT COUNT(*) FROM format_test t, LATERAL read_duck_hunt_log(t.path, 'gcc_text') e;
----
0

# Verify auto works (proves the file has content)
query I
SELECT COUNT(*) > 0 FROM format_test t, LATERAL read_duck_hunt_log(t.path, 'auto') e;
----
true

statement ok
DROP TABLE format_test;

# =============================================================================

# Basic lateral join
statement ok
CREATE TABLE log_contents AS
SELECT 'test.c:10: error: something failed' as content, 'file1' as name
UNION ALL
SELECT 'util.c:20: warning: check this' as content, 'file2' as name;

query III
SELECT l.name, e.status, e.message
FROM log_contents l, LATERAL parse_duck_hunt_log(l.content, 'generic_lint') e
ORDER BY l.name;
----
file1	ERROR	something failed
file2	WARNING	check this

# Multiple events per input row
statement ok
CREATE TABLE multi_event AS SELECT
'a.c:1: error: first error
b.c:2: error: second error' as content;

query I
SELECT COUNT(*)
FROM multi_event m, LATERAL parse_duck_hunt_log(m.content, 'generic_lint') e;
----
2

# Verify all events are extracted
query II
SELECT e.ref_file, e.message
FROM multi_event m, LATERAL parse_duck_hunt_log(m.content, 'generic_lint') e
ORDER BY e.ref_line;
----
a.c	first error
b.c	second error

# With format auto-detection
query II
SELECT l.name, COUNT(*)
FROM log_contents l, LATERAL parse_duck_hunt_log(l.content) e
GROUP BY l.name
ORDER BY l.name;
----
file1	1
file2	1

# Early termination with LIMIT
query I
SELECT COUNT(*) FROM (
    SELECT * FROM log_contents l,
    LATERAL parse_duck_hunt_log(l.content, 'generic_lint') e
    LIMIT 1
);
----
1

# Test with VALUES clause
query II
SELECT t.id, e.status
FROM (VALUES (1, 'x.c:1: error: test'), (2, 'y.c:2: warning: other')) AS t(id, content),
     LATERAL parse_duck_hunt_log(t.content, 'generic_lint') e
ORDER BY t.id;
----
1	ERROR
2	WARNING

# Test with filtering in lateral context
query II
SELECT l.name, e.status
FROM log_contents l, LATERAL parse_duck_hunt_log(l.content, 'generic_lint') e
WHERE e.status = 'ERROR'
ORDER BY l.name;
----
file1	ERROR

# Test with JSON format in lateral join
statement ok
CREATE TABLE eslint_logs AS
SELECT 1 as file_id, '[{"filePath":"a.js","messages":[{"severity":2,"message":"unused var","line":1,"column":1}]}]' as content
UNION ALL
SELECT 2 as file_id, '[{"filePath":"b.js","messages":[{"severity":1,"message":"prefer const","line":5,"column":3}]}]' as content;

query III
SELECT l.file_id, e.ref_file, e.status
FROM eslint_logs l, LATERAL parse_duck_hunt_log(l.content, 'eslint_json') e
WHERE e.event_type != 'summary'
ORDER BY l.file_id;
----
1	a.js	ERROR
2	b.js	WARNING

# Test empty input produces no output rows
statement ok
CREATE TABLE empty_log AS SELECT '' as content;

query I
SELECT COUNT(*)
FROM empty_log l, LATERAL parse_duck_hunt_log(l.content, 'generic_lint') e;
----
0

# Test lateral join with subquery
query II
SELECT sq.category, e.status
FROM (
    SELECT 'errors' as category, 'x.c:1: error: fail' as content
    UNION ALL
    SELECT 'warnings' as category, 'y.c:2: warning: warn' as content
) sq, LATERAL parse_duck_hunt_log(sq.content, 'generic_lint') e
ORDER BY sq.category;
----
errors	ERROR
warnings	WARNING

# =============================================================================
# Edge Cases and Failure Handling for parse_duck_hunt_log
# =============================================================================

# Test NULL content handling
statement ok
CREATE TABLE null_content AS
SELECT 'valid' as name, 'x.c:1: error: test' as content
UNION ALL
SELECT 'null_val' as name, NULL as content
UNION ALL
SELECT 'another' as name, 'y.c:2: warning: warn' as content;

# NULL content should produce no rows for that input
query II
SELECT l.name, e.status
FROM null_content l, LATERAL parse_duck_hunt_log(l.content, 'generic_lint') e
ORDER BY l.name;
----
another	WARNING
valid	ERROR

# NOTE: Named parameters (severity_threshold, content, context) are not supported
# in LATERAL join context - DuckDB interprets them as column references.
# Use direct function calls for those features.

# Test LEFT JOIN behavior - rows without matches preserved
query II
SELECT l.name, COALESCE(e.status, 'NO_MATCH') as status
FROM null_content l
LEFT JOIN LATERAL parse_duck_hunt_log(l.content, 'generic_lint') e ON true
ORDER BY l.name;
----
another	WARNING
null_val	NO_MATCH
valid	ERROR

# Test with CTE
query II
WITH error_logs AS (
    SELECT 'build1' as build, 'src/a.c:10: error: undefined' as log
    UNION ALL
    SELECT 'build2' as build, 'src/b.c:20: error: syntax error' as log
)
SELECT c.build, e.ref_file
FROM error_logs c, LATERAL parse_duck_hunt_log(c.log, 'generic_lint') e
ORDER BY c.build;
----
build1	src/a.c
build2	src/b.c

# Test aggregations with lateral join
query II
SELECT l.name, COUNT(*) as event_count
FROM log_contents l, LATERAL parse_duck_hunt_log(l.content, 'generic_lint') e
GROUP BY l.name
ORDER BY l.name;
----
file1	1
file2	1

# Test with multi-event content and aggregation
statement ok
CREATE TABLE multi_error AS SELECT
'file1' as build,
'a.c:1: error: err1
b.c:2: warning: warn1
c.c:3: error: err2' as content;

query III
SELECT m.build, e.status, COUNT(*) as cnt
FROM multi_error m, LATERAL parse_duck_hunt_log(m.content, 'generic_lint') e
GROUP BY m.build, e.status
ORDER BY e.status;
----
file1	ERROR	2
file1	WARNING	1

# Test window functions with lateral join
query III
SELECT l.name, e.status, ROW_NUMBER() OVER (PARTITION BY l.name ORDER BY e.ref_line) as rn
FROM log_contents l, LATERAL parse_duck_hunt_log(l.content, 'generic_lint') e
ORDER BY l.name, rn;
----
file1	ERROR	1
file2	WARNING	1

# Test DISTINCT with lateral join
query I
SELECT DISTINCT e.status
FROM log_contents l, LATERAL parse_duck_hunt_log(l.content, 'generic_lint') e
ORDER BY e.status;
----
ERROR
WARNING

# Test ORDER BY on lateral columns
query III
SELECT l.name, e.status, e.ref_line
FROM log_contents l, LATERAL parse_duck_hunt_log(l.content, 'generic_lint') e
ORDER BY e.ref_line DESC;
----
file2	WARNING	20
file1	ERROR	10

# Test with auto format in lateral context
query I
SELECT COUNT(*) > 0 as has_results
FROM log_contents l, LATERAL parse_duck_hunt_log(l.content, 'auto') e;
----
true

# Test with regexp format in lateral context
query II
SELECT l.name, e.message
FROM log_contents l, LATERAL parse_duck_hunt_log(l.content, 'regexp:(?P<file>\S+):(?P<line>\d+):\s*(?P<severity>\w+):\s*(?P<message>.*)') e
ORDER BY l.name;
----
file1	something failed
file2	check this

# Test nested lateral joins (lateral on lateral result)
statement ok
CREATE TABLE nested_test AS SELECT 1 as id, 'x.c:1: error: outer' as content;

query II
SELECT n.id, e.status
FROM nested_test n, LATERAL parse_duck_hunt_log(n.content, 'generic_lint') e
ORDER BY n.id;
----
1	ERROR

# Test UNION with lateral joins
query II
SELECT 'set1' as source, e.status
FROM log_contents l, LATERAL parse_duck_hunt_log(l.content, 'generic_lint') e
WHERE l.name = 'file1'
UNION ALL
SELECT 'set2' as source, e.status
FROM log_contents l, LATERAL parse_duck_hunt_log(l.content, 'generic_lint') e
WHERE l.name = 'file2'
ORDER BY source;
----
set1	ERROR
set2	WARNING

# Cleanup edge case tables
statement ok
DROP TABLE null_content;

statement ok
DROP TABLE multi_error;

statement ok
DROP TABLE nested_test;

# =============================================================================
# Tests for read_duck_hunt_log with LATERAL joins (file-based)
# =============================================================================

# Create a table with file paths
statement ok
CREATE TABLE log_files AS
SELECT 'test/samples/make.out' as path, 'make' as test_type
UNION ALL
SELECT 'test/samples/mypy.txt' as path, 'mypy' as test_type;

# Basic lateral join with read_duck_hunt_log (auto-detection)
# gcc_text has higher priority, so make.out returns 4 GCC diagnostics
query II
SELECT l.test_type, COUNT(*)
FROM log_files l, LATERAL read_duck_hunt_log(l.path) e
GROUP BY l.test_type
ORDER BY l.test_type;
----
make	4
mypy	4

# Test each file with its correct explicit format
query I
SELECT COUNT(*) FROM read_duck_hunt_log('test/samples/make.out', 'gcc_text');
----
4

query I
SELECT COUNT(*) FROM read_duck_hunt_log('test/samples/mypy.txt', 'mypy_text');
----
4

# Lateral join with auto-detection - gcc_text selected for make.out
query III
SELECT l.test_type, e.status, COUNT(*)
FROM log_files l, LATERAL read_duck_hunt_log(l.path, 'auto') e
GROUP BY l.test_type, e.status
ORDER BY l.test_type, e.status;
----
make	ERROR	2
make	INFO	1
make	WARNING	1
mypy	ERROR	3
mypy	WARNING	1

# Lateral join with explicit mypy_text format for mypy files
query III
SELECT l.test_type, e.status, COUNT(*)
FROM log_files l, LATERAL read_duck_hunt_log(l.path, 'mypy_text') e
WHERE l.test_type = 'mypy'
GROUP BY l.test_type, e.status
ORDER BY l.test_type, e.status;
----
mypy	ERROR	3
mypy	WARNING	1

# Test with non-existent files returns empty (not error)
statement ok
CREATE TABLE missing_files AS SELECT '/nonexistent/path.log' as path;

query I
SELECT COUNT(*)
FROM missing_files m, LATERAL read_duck_hunt_log(m.path) e;
----
0

# Test filtering within lateral join (auto-detection)
query II
SELECT l.test_type, e.ref_file
FROM log_files l, LATERAL read_duck_hunt_log(l.path) e
WHERE e.status = 'ERROR'
ORDER BY l.test_type, e.ref_file
LIMIT 3;
----
make	src/main.c
make	src/utils.c
mypy	src/api/routes.py

# Test filtering with explicit gcc_text format on C files
query II
SELECT l.test_type, e.ref_file
FROM log_files l, LATERAL read_duck_hunt_log(l.path, 'gcc_text') e
WHERE e.status = 'ERROR' AND l.test_type = 'make'
ORDER BY l.test_type, e.ref_file
LIMIT 3;
----
make	src/main.c
make	src/utils.c

# Test NULL file path handling
statement ok
CREATE TABLE null_paths AS
SELECT 'valid' as name, 'test/samples/make.out' as path
UNION ALL
SELECT 'null_path' as name, NULL as path
UNION ALL
SELECT 'another' as name, 'test/samples/mypy.txt' as path;

# NULL paths should produce no rows for that input (auto-detection)
query II
SELECT l.name, COUNT(*) as events
FROM null_paths l, LATERAL read_duck_hunt_log(l.path) e
GROUP BY l.name
ORDER BY l.name;
----
another	4
valid	4

# NULL paths with explicit gcc_text format
query II
SELECT l.name, COUNT(*) as events
FROM null_paths l, LATERAL read_duck_hunt_log(l.path, 'gcc_text') e
GROUP BY l.name
ORDER BY l.name;
----
valid	4

# Test LEFT JOIN with NULL/missing files - NULL path preserved with NO_FILE
query II
SELECT l.name, COALESCE(e.status, 'NO_FILE') as status
FROM null_paths l
LEFT JOIN LATERAL read_duck_hunt_log(l.path) e ON true
WHERE l.name = 'null_path'
ORDER BY l.name;
----
null_path	NO_FILE

# NOTE: Named parameters are not supported in LATERAL context

# Test with CTE and read_duck_hunt_log (auto-detection)
query II
WITH file_list AS (
    SELECT 'make' as tool, 'test/samples/make.out' as log_path
    UNION ALL
    SELECT 'mypy' as tool, 'test/samples/mypy.txt' as log_path
)
SELECT f.tool, COUNT(*) as total
FROM file_list f, LATERAL read_duck_hunt_log(f.log_path) e
GROUP BY f.tool
ORDER BY f.tool;
----
make	4
mypy	4

# Test with CTE and explicit gcc_text format
query II
WITH file_list AS (
    SELECT 'make' as tool, 'test/samples/make.out' as log_path
    UNION ALL
    SELECT 'mypy' as tool, 'test/samples/mypy.txt' as log_path
)
SELECT f.tool, COUNT(*) as total
FROM file_list f, LATERAL read_duck_hunt_log(f.log_path, 'gcc_text') e
GROUP BY f.tool
ORDER BY f.tool;
----
make	4

# Test aggregation across multiple files
query I
SELECT COUNT(DISTINCT e.tool_name) as distinct_tools
FROM log_files l, LATERAL read_duck_hunt_log(l.path) e;
----
2

# Test window function with read_duck_hunt_log
query III
SELECT l.test_type, e.status,
       ROW_NUMBER() OVER (PARTITION BY l.test_type ORDER BY e.ref_line) as rn
FROM log_files l, LATERAL read_duck_hunt_log(l.path) e
WHERE e.status = 'ERROR'
ORDER BY l.test_type, rn
LIMIT 4;
----
make	ERROR	1
make	ERROR	2
mypy	ERROR	1
mypy	ERROR	2

# Test UNION with read_duck_hunt_log lateral joins
query II
SELECT 'make_errors' as category, COUNT(*) as cnt
FROM (SELECT 'test/samples/make.out' as p) t, LATERAL read_duck_hunt_log(t.p) e
WHERE e.status = 'ERROR'
UNION ALL
SELECT 'mypy_errors' as category, COUNT(*) as cnt
FROM (SELECT 'test/samples/mypy.txt' as p) t, LATERAL read_duck_hunt_log(t.p) e
WHERE e.status = 'ERROR'
ORDER BY category;
----
make_errors	2
mypy_errors	3

# Test empty file handling (file exists but no parseable content)
statement ok
CREATE TABLE edge_files AS SELECT '/dev/null' as path;

query I
SELECT COUNT(*)
FROM edge_files ef, LATERAL read_duck_hunt_log(ef.path) e;
----
0

# Test multiple references to same lateral result
query I
SELECT COUNT(*)
FROM log_files l, LATERAL read_duck_hunt_log(l.path) e
WHERE e.status = e.status  -- trivial self-reference
  AND l.test_type = 'make';
----
4

# Clean up edge case tables
statement ok
DROP TABLE null_paths;

statement ok
DROP TABLE edge_files;

# Clean up file tables
statement ok
DROP TABLE log_files;

statement ok
DROP TABLE missing_files;

# Cleanup
statement ok
DROP TABLE log_contents;

statement ok
DROP TABLE multi_event;

statement ok
DROP TABLE eslint_logs;

statement ok
DROP TABLE empty_log;
