# name: test/sql/duck_hunt.test
# description: test duck_hunt extension core functionality
# group: [sql]

# Require statement will ensure this test is run with this extension loaded
require duck_hunt

# Test read_duck_hunt_log function with sample data
statement ok
CREATE TABLE test_data AS 
SELECT * FROM read_duck_hunt_log('workspace/eslint_sample.json', 'eslint_json');

# Verify ESLint parsing results
query III
SELECT COUNT(*), 
       COUNT(CASE WHEN status = 'ERROR' THEN 1 END) as errors,
       COUNT(CASE WHEN status = 'WARNING' THEN 1 END) as warnings
FROM test_data;
----
3	1	2

# Test parse_duck_hunt_log function with string input
query IIII
SELECT event_id, tool_name, status, error_code
FROM parse_duck_hunt_log('[{"filePath":"/test.js","messages":[{"ruleId":"no-unused-vars","severity":2,"message":"test error","line":1,"column":8}]}]', 'eslint_json');
----
1	eslint	ERROR	no-unused-vars

# Test format auto-detection
query III
SELECT tool_name, status, test_name
FROM parse_duck_hunt_log('{"Action":"run","Package":"github.com/test","Test":"TestExample"}
{"Action":"fail","Package":"github.com/test","Test":"TestExample","Elapsed":0.001}
{"Action":"run","Package":"github.com/test","Test":"TestWorking"}
{"Action":"pass","Package":"github.com/test","Test":"TestWorking","Elapsed":0.002}', 'auto')
ORDER BY event_id;
----
go_test	FAIL	TestExample
go_test	PASS	TestWorking

# Test generic lint parsing
query IIII
SELECT tool_name, ref_file, ref_line, status
FROM parse_duck_hunt_log('src/main.c:15:5: error: undeclared variable
src/utils.c:20:1: warning: unused function', 'generic_lint')
ORDER BY event_id;
----
lint	src/main.c	15	ERROR
lint	src/utils.c	20	WARNING

# Test make error parsing
query I
SELECT COUNT(*) FROM parse_duck_hunt_log('src/main.c:15:5: error: undeclared_var
make: *** [Makefile:23: build/main] Error 1', 'make_error');
----
2

# Test ValidationEvent schema completeness
query I
SELECT COUNT(*) FROM (
  SELECT event_id, tool_name, event_type, ref_file, ref_line, 
         ref_column, function_name, status, severity, category, 
         message, suggestion, error_code, test_name, execution_time, 
         log_content, structured_data
  FROM parse_duck_hunt_log('src/test.c:1:1: error: test', 'generic_lint')
);
----
1

# Test empty input handling
query I
SELECT COUNT(*) FROM parse_duck_hunt_log('', 'auto');
----
0

# Test invalid JSON handling
query I
SELECT COUNT(*) FROM parse_duck_hunt_log('invalid json}', 'auto');
----
0

# Test status_badge function - string overload
query IIII
SELECT status_badge('ok'), status_badge('fail'), status_badge('warn'), status_badge('running');
----
[ OK ]	[FAIL]	[WARN]	[ .. ]

# Test status_badge function - case insensitivity and aliases
query III
SELECT status_badge('PASSED'), status_badge('ERROR'), status_badge('warning');
----
[ OK ]	[FAIL]	[WARN]

# Test status_badge function - unknown status
query I
SELECT status_badge('unknown_status');
----
[ ?? ]

# Test status_badge function - count overload with 3 args
query IIII
SELECT status_badge(0, 0, false), status_badge(1, 0, false), status_badge(0, 5, false), status_badge(0, 0, true);
----
[ OK ]	[FAIL]	[WARN]	[ .. ]

# Test status_badge function - count overload with 2 args
query III
SELECT status_badge(0, 0), status_badge(3, 0), status_badge(0, 2);
----
[ OK ]	[FAIL]	[WARN]

# Test status_badge function - error takes precedence over warning
query I
SELECT status_badge(5, 10, false);
----
[FAIL]

# Test status_badge function - running takes precedence over errors
query I
SELECT status_badge(5, 10, true);
----
[ .. ]

# Clean up
statement ok
DROP TABLE test_data;
