# name: test/sql/new_formats.test
# description: test new RuboCop JSON and Cargo test JSON formats
# group: [sql]

require duck_hunt

# Test 1: RuboCop JSON format parsing
statement ok
CREATE TABLE rubocop_results AS 
SELECT * FROM read_duck_hunt_log('workspace/rubocop_sample.json', 'rubocop_json');

# Verify RuboCop parsing results
query IIII
SELECT COUNT(*), tool_name,
       COUNT(CASE WHEN status = 'ERROR' THEN 1 END) as errors,
       COUNT(CASE WHEN status = 'WARNING' THEN 1 END) as warnings
FROM rubocop_results
GROUP BY tool_name;
----
4	rubocop	1	3

# Test 2: Cargo test JSON format parsing
statement ok
CREATE TABLE cargo_results AS 
SELECT * FROM read_duck_hunt_log('workspace/cargo_test_sample.json', 'cargo_test_json');

# Verify Cargo test parsing results
query IIII
SELECT COUNT(*), tool_name,
       COUNT(CASE WHEN status = 'PASS' THEN 1 END) as passes,
       COUNT(CASE WHEN status = 'FAIL' THEN 1 END) as fails
FROM cargo_results
GROUP BY tool_name;
----
4	cargo_test	2	1

# Test 3: RuboCop auto-detection
query I
SELECT DISTINCT tool_name FROM parse_duck_hunt_log('{"files":[{"path":"test.rb","offenses":[{"severity":"error","cop_name":"TestCop","message":"Test message","location":{"start_line":1,"start_column":1}}]}]}', 'auto');
----
rubocop

# Test 4: Cargo test auto-detection
query I
SELECT DISTINCT tool_name FROM parse_duck_hunt_log('{"type":"test","event":"started","name":"test::example"}
{"type":"test","event":"ok","name":"test::example","exec_time":0.001}', 'auto');
----
cargo_test

# Test 5: RuboCop field validation
query IIII
SELECT ref_file, ref_line, error_code, severity
FROM parse_duck_hunt_log('{"files":[{"path":"/src/test.rb","offenses":[{"severity":"convention","cop_name":"Style/TestRule","message":"Test convention","location":{"start_line":5,"start_column":10}}]}]}', 'rubocop_json');
----
/src/test.rb	5	Style/TestRule	convention

# Test 6: Cargo test field validation
query IIII
SELECT test_name, status, execution_time > 0 as has_time, message
FROM parse_duck_hunt_log('{"type":"test","event":"started","name":"module::test_function"}
{"type":"test","event":"failed","name":"module::test_function","exec_time":0.123,"stdout":"assertion failed"}', 'cargo_test_json');
----
module::test_function	FAIL	true	Test failed: assertion failed

# Test 7: RuboCop severity mapping
query II
SELECT severity, status FROM parse_duck_hunt_log('{"files":[{"path":"test.rb","offenses":[{"severity":"error","cop_name":"TestCop","message":"Error msg","location":{"start_line":1,"start_column":1}},{"severity":"warning","cop_name":"TestCop2","message":"Warning msg","location":{"start_line":2,"start_column":1}},{"severity":"convention","cop_name":"TestCop3","message":"Convention msg","location":{"start_line":3,"start_column":1}}]}]}', 'rubocop_json')
ORDER BY event_id;
----
error	ERROR
warning	WARNING
convention	WARNING

# Test 8: Cargo test ignored status
query II
SELECT status, message FROM parse_duck_hunt_log('{"type":"test","event":"started","name":"test::ignored_test"}
{"type":"test","event":"ignored","name":"test::ignored_test","exec_time":0.001}', 'cargo_test_json');
----
SKIP	Test ignored

# Test 9: RuboCop with no offenses
query I
SELECT COUNT(*) FROM parse_duck_hunt_log('{"files":[{"path":"test.rb","offenses":[]}]}', 'rubocop_json');
----
0

# Test 10: Cargo test with failure details
query I
SELECT message LIKE '%assertion failed%' as has_failure_details FROM parse_duck_hunt_log('{"type":"test","event":"started","name":"test::failing"}
{"type":"test","event":"failed","name":"test::failing","exec_time":0.001,"stdout":"assertion failed: expected true"}', 'cargo_test_json');
----
true

# Test 11: RuboCop event type validation
query I
SELECT DISTINCT event_type FROM parse_duck_hunt_log('{"files":[{"path":"test.rb","offenses":[{"severity":"error","cop_name":"TestCop","message":"Test","location":{"start_line":1,"start_column":1}}]}]}', 'rubocop_json');
----
lint_issue

# Test 12: Cargo test event type validation
query I
SELECT DISTINCT event_type FROM parse_duck_hunt_log('{"type":"test","event":"started","name":"test::example"}
{"type":"test","event":"ok","name":"test::example","exec_time":0.001}', 'cargo_test_json');
----
test_result

# Test 13: RuboCop category field
query I
SELECT DISTINCT category FROM parse_duck_hunt_log('{"files":[{"path":"test.rb","offenses":[{"severity":"error","cop_name":"TestCop","message":"Test","location":{"start_line":1,"start_column":1}}]}]}', 'rubocop_json');
----
code_quality

# Test 14: Cargo test category field
query I
SELECT DISTINCT category FROM parse_duck_hunt_log('{"type":"test","event":"started","name":"test::example"}
{"type":"test","event":"ok","name":"test::example","exec_time":0.001}', 'cargo_test_json');
----
test

# Test 15: RuboCop location parsing
query II
SELECT ref_line, ref_column FROM parse_duck_hunt_log('{"files":[{"path":"test.rb","offenses":[{"severity":"error","cop_name":"TestCop","message":"Test","location":{"start_line":15,"start_column":25}}]}]}', 'rubocop_json');
----
15	25

# Test 16: SwiftLint JSON format parsing
statement ok
CREATE TABLE swiftlint_results AS 
SELECT * FROM read_duck_hunt_log('workspace/swiftlint_sample.json', 'swiftlint_json');

# Verify SwiftLint parsing results
query IIII
SELECT COUNT(*), tool_name,
       COUNT(CASE WHEN status = 'ERROR' THEN 1 END) as errors,
       COUNT(CASE WHEN status = 'WARNING' THEN 1 END) as warnings
FROM swiftlint_results
GROUP BY tool_name;
----
5	swiftlint	2	3

# Test 17: PHPStan JSON format parsing
statement ok
CREATE TABLE phpstan_results AS 
SELECT * FROM read_duck_hunt_log('workspace/phpstan_sample.json', 'phpstan_json');

# Verify PHPStan parsing results
query IIII
SELECT COUNT(*), tool_name,
       COUNT(CASE WHEN status = 'ERROR' THEN 1 END) as errors,
       COUNT(CASE WHEN status = 'WARNING' THEN 1 END) as warnings
FROM phpstan_results
GROUP BY tool_name;
----
3	phpstan	2	1

# Test 18: SwiftLint auto-detection
query I
SELECT DISTINCT tool_name FROM parse_duck_hunt_log('[{"file":"test.swift","rule_id":"test_rule","severity":"warning","reason":"Test message","line":1,"column":1}]', 'auto');
----
swiftlint

# Test 19: PHPStan auto-detection
query I
SELECT DISTINCT tool_name FROM parse_duck_hunt_log('{"totals":{"errors":1},"files":{"/test.php":{"errors":1,"messages":[{"message":"Test error","line":1,"ignorable":false}]}}}', 'auto');
----
phpstan

# Test 20: SwiftLint field validation
query IIII
SELECT ref_file, ref_line, error_code, severity
FROM parse_duck_hunt_log('[{"file":"/src/Test.swift","rule_id":"force_cast","severity":"error","reason":"Force casts should be avoided","line":10,"column":5}]', 'swiftlint_json');
----
/src/Test.swift	10	force_cast	error

# Test 21: PHPStan field validation
query IIII
SELECT ref_file, ref_line, status, category
FROM parse_duck_hunt_log('{"files":{"/src/Test.php":{"messages":[{"message":"Test error","line":25,"ignorable":false}]}}}', 'phpstan_json');
----
/src/Test.php	25	ERROR	static_analysis

# Test 22: SwiftLint event type validation
query I
SELECT DISTINCT event_type FROM parse_duck_hunt_log('[{"file":"test.swift","rule_id":"test_rule","severity":"warning","reason":"Test","line":1,"column":1}]', 'swiftlint_json');
----
lint_issue

# Test 23: PHPStan event type validation
query I
SELECT DISTINCT event_type FROM parse_duck_hunt_log('{"files":{"test.php":{"messages":[{"message":"Test","line":1,"ignorable":false}]}}}', 'phpstan_json');
----
lint_issue

# Test 24: SwiftLint suggestion field (type)
query I
SELECT suggestion FROM parse_duck_hunt_log('[{"file":"test.swift","rule_id":"test_rule","type":"Force Cast","severity":"error","reason":"Test","line":1,"column":1}]', 'swiftlint_json');
----
Force Cast

# Test 25: PHPStan ignorable status mapping
query II
SELECT status, severity FROM parse_duck_hunt_log('{"files":{"test.php":{"messages":[{"message":"Ignorable issue","line":1,"ignorable":true},{"message":"Critical issue","line":2,"ignorable":false}]}}}', 'phpstan_json')
ORDER BY event_id;
----
WARNING	warning
ERROR	error

# Test 26: ShellCheck JSON format parsing
statement ok
CREATE TABLE shellcheck_results AS 
SELECT * FROM read_duck_hunt_log('workspace/shellcheck_sample.json', 'shellcheck_json');

# Verify ShellCheck parsing results
query IIII
SELECT COUNT(*), tool_name,
       COUNT(CASE WHEN status = 'ERROR' THEN 1 END) as errors,
       COUNT(CASE WHEN status = 'WARNING' THEN 1 END) as warnings
FROM shellcheck_results
GROUP BY tool_name;
----
5	shellcheck	2	2

# Test 27: ShellCheck auto-detection
query I
SELECT DISTINCT tool_name FROM parse_duck_hunt_log('[{"file":"test.sh","line":1,"column":1,"level":"error","code":"SC2086","message":"Test message"}]', 'auto');
----
shellcheck

# Test 28: ShellCheck field validation
query IIII
SELECT ref_file, ref_line, error_code, severity
FROM parse_duck_hunt_log('[{"file":"/src/script.sh","line":10,"column":5,"level":"warning","code":"SC2034","message":"Variable unused"}]', 'shellcheck_json');
----
/src/script.sh	10	SC2034	warning

# Test 29: ShellCheck severity mapping
query II
SELECT severity, status FROM parse_duck_hunt_log('[{"file":"test.sh","line":1,"column":1,"level":"error","code":"SC1","message":"Error"},{"file":"test.sh","line":2,"column":1,"level":"warning","code":"SC2","message":"Warning"},{"file":"test.sh","line":3,"column":1,"level":"info","code":"SC3","message":"Info"},{"file":"test.sh","line":4,"column":1,"level":"style","code":"SC4","message":"Style"}]', 'shellcheck_json')
ORDER BY event_id;
----
error	ERROR
warning	WARNING
info	INFO
style	WARNING

# Test 30: ShellCheck event type and category validation
query II
SELECT DISTINCT event_type, category FROM parse_duck_hunt_log('[{"file":"test.sh","line":1,"column":1,"level":"error","code":"SC2086","message":"Test"}]', 'shellcheck_json');
----
lint_issue	shell_script

# Test 31: ShellCheck fix suggestion detection
query I
SELECT suggestion FROM parse_duck_hunt_log('[{"file":"test.sh","line":1,"column":1,"level":"error","code":"SC2086","message":"Test","fix":{"replacements":[{"line":1,"column":1,"replacement":"\"$var\""}]}}]', 'shellcheck_json');
----
Fix available

# Test 32: stylelint JSON format parsing
statement ok
CREATE TABLE stylelint_results AS 
SELECT * FROM read_duck_hunt_log('workspace/stylelint_sample.json', 'stylelint_json');

# Verify stylelint parsing results
query IIII
SELECT COUNT(*), tool_name,
       COUNT(CASE WHEN status = 'ERROR' THEN 1 END) as errors,
       COUNT(CASE WHEN status = 'WARNING' THEN 1 END) as warnings
FROM stylelint_results
GROUP BY tool_name;
----
5	stylelint	3	2

# Test 33: stylelint auto-detection
query I
SELECT DISTINCT tool_name FROM parse_duck_hunt_log('[{"source":"test.css","warnings":[{"line":1,"column":1,"rule":"color-no-invalid-hex","severity":"error","text":"Invalid hex color"}]}]', 'auto');
----
stylelint

# Test 34: stylelint field validation
query IIII
SELECT ref_file, ref_line, error_code, severity
FROM parse_duck_hunt_log('[{"source":"/styles/main.css","warnings":[{"line":10,"column":5,"rule":"color-no-invalid-hex","severity":"error","text":"Invalid hex color"}]}]', 'stylelint_json');
----
/styles/main.css	10	color-no-invalid-hex	error

# Test 35: stylelint severity mapping
query II
SELECT severity, status FROM parse_duck_hunt_log('[{"source":"test.css","warnings":[{"line":1,"column":1,"rule":"rule1","severity":"error","text":"Error"},{"line":2,"column":1,"rule":"rule2","severity":"warning","text":"Warning"}]}]', 'stylelint_json')
ORDER BY event_id;
----
error	ERROR
warning	WARNING

# Test 36: stylelint event type and category validation
query II
SELECT DISTINCT event_type, category FROM parse_duck_hunt_log('[{"source":"test.css","warnings":[{"line":1,"column":1,"rule":"color-no-invalid-hex","severity":"error","text":"Invalid hex color"}]}]', 'stylelint_json');
----
lint_issue	css_style

# Test 37: stylelint with no warnings
query I
SELECT COUNT(*) FROM parse_duck_hunt_log('[{"source":"clean.css","warnings":[]}]', 'stylelint_json');
----
0

# Test 38: Clippy JSON format parsing
statement ok
CREATE TABLE clippy_results AS 
SELECT * FROM read_duck_hunt_log('workspace/clippy_sample.json', 'clippy_json');

# Verify Clippy parsing results
query II
SELECT COUNT(*), tool_name
FROM clippy_results
GROUP BY tool_name;
----
4	clippy

# Test 39: Clippy auto-detection
query I
SELECT DISTINCT tool_name FROM parse_duck_hunt_log('{"message":{"message":"test warning","spans":[{"file_name":"test.rs","line_start":1,"column_start":1,"is_primary":true}],"level":"warn"}}', 'auto');
----
clippy

# Test 40: Clippy field validation
query IIII
SELECT ref_file, ref_line, error_code, severity
FROM parse_duck_hunt_log('{"message":{"message":"test warning","code":{"code":"test_lint"},"spans":[{"file_name":"src/test.rs","line_start":10,"column_start":5,"is_primary":true}],"level":"warn"}}', 'clippy_json');
----
src/test.rs	10	test_lint	warn

# Test 41: Clippy severity mapping
query II
SELECT severity, status FROM parse_duck_hunt_log('{"message":{"message":"test error","level":"error","spans":[{"file_name":"test.rs","line_start":1,"column_start":1,"is_primary":true}]}}
{"message":{"message":"test warning","level":"warn","spans":[{"file_name":"test.rs","line_start":2,"column_start":1,"is_primary":true}]}}', 'clippy_json')
ORDER BY event_id;
----
error	ERROR
warn	WARNING

# Test 42: Clippy event type and category validation
query II
SELECT DISTINCT event_type, category FROM parse_duck_hunt_log('{"message":{"message":"test warning","spans":[{"file_name":"test.rs","line_start":1,"column_start":1,"is_primary":true}],"level":"warn"}}', 'clippy_json');
----
lint_issue	code_quality

# Test 43: Clippy suggestion extraction
query I
SELECT suggestion FROM parse_duck_hunt_log('{"message":{"message":"test warning","spans":[{"file_name":"test.rs","line_start":1,"column_start":1,"is_primary":true,"suggested_replacement":"fixed_code"}],"level":"warn"}}', 'clippy_json');
----
fixed_code

# Test 44: markdownlint JSON format parsing
statement ok
CREATE TABLE markdownlint_results AS 
SELECT * FROM read_duck_hunt_log('workspace/markdownlint_sample.json', 'markdownlint_json');

# Verify markdownlint parsing results
query II
SELECT COUNT(*), tool_name
FROM markdownlint_results
GROUP BY tool_name;
----
5	markdownlint

# Test 45: markdownlint auto-detection
query I
SELECT DISTINCT tool_name FROM parse_duck_hunt_log('[{"fileName":"test.md","lineNumber":1,"ruleNames":["MD041"],"ruleDescription":"First line heading issue"}]', 'auto');
----
markdownlint

# Test 46: markdownlint field validation
query IIII
SELECT ref_file, ref_line, error_code, category
FROM parse_duck_hunt_log('[{"fileName":"docs/README.md","lineNumber":5,"ruleNames":["MD032","blanks-around-lists"],"ruleDescription":"Lists should be surrounded by blank lines"}]', 'markdownlint_json');
----
docs/README.md	5	MD032	documentation

# Test 47: markdownlint event type validation
query I
SELECT DISTINCT event_type FROM parse_duck_hunt_log('[{"fileName":"test.md","lineNumber":1,"ruleNames":["MD041"],"ruleDescription":"Test"}]', 'markdownlint_json');
----
lint_issue

# Test 48: markdownlint suggestion extraction from errorDetail
query I
SELECT suggestion FROM parse_duck_hunt_log('[{"fileName":"test.md","lineNumber":1,"ruleNames":["MD013"],"ruleDescription":"Line length","errorDetail":"Expected: 80; Actual: 95"}]', 'markdownlint_json');
----
Expected: 80; Actual: 95

# Test 49: yamllint JSON format parsing
statement ok
CREATE TABLE yamllint_results AS 
SELECT * FROM read_duck_hunt_log('workspace/yamllint_sample.json', 'yamllint_json');

# Verify yamllint parsing results
query III
SELECT COUNT(*), tool_name, COUNT(CASE WHEN status = 'ERROR' THEN 1 END) as errors
FROM yamllint_results
GROUP BY tool_name;
----
5	yamllint	3

# Test 50: yamllint auto-detection
query I
SELECT DISTINCT tool_name FROM parse_duck_hunt_log('[{"file":"test.yml","line":1,"column":1,"level":"error","rule":"indentation","message":"wrong indentation"}]', 'auto');
----
yamllint

# Test 51: yamllint field validation
query IIII
SELECT ref_file, ref_line, error_code, category
FROM parse_duck_hunt_log('[{"file":"config.yaml","line":5,"column":10,"level":"error","rule":"line_length","message":"line too long"}]', 'yamllint_json');
----
config.yaml	5	line_length	configuration

# Test 52: yamllint severity mapping
query II
SELECT severity, status FROM parse_duck_hunt_log('[{"file":"test.yml","line":1,"column":1,"level":"error","rule":"test","message":"Error"},{"file":"test.yml","line":2,"column":1,"level":"warning","rule":"test2","message":"Warning"}]', 'yamllint_json')
ORDER BY event_id;
----
error	ERROR
warning	WARNING

# Test 53: Bandit JSON format parsing
statement ok
CREATE TABLE bandit_results AS 
SELECT * FROM read_duck_hunt_log('workspace/bandit_sample.json', 'bandit_json');

# Verify Bandit parsing results
query IIII
SELECT COUNT(*), tool_name,
       COUNT(CASE WHEN status = 'ERROR' THEN 1 END) as errors,
       COUNT(CASE WHEN status = 'WARNING' THEN 1 END) as warnings
FROM bandit_results
GROUP BY tool_name;
----
4	bandit	1	1

# Test 54: Bandit auto-detection
query I
SELECT DISTINCT tool_name FROM parse_duck_hunt_log('{"results":[{"test_id":"B101","issue_severity":"HIGH","issue_confidence":"HIGH","filename":"test.py","line_number":1,"issue_text":"Test security issue"}]}', 'auto');
----
bandit

# Test 55: Bandit field validation
query IIII
SELECT ref_file, ref_line, error_code, severity
FROM parse_duck_hunt_log('{"results":[{"filename":"src/auth.py","line_number":45,"test_id":"B608","issue_severity":"HIGH","issue_confidence":"HIGH","issue_text":"SQL injection vulnerability"}]}', 'bandit_json');
----
src/auth.py	45	B608	HIGH

# Test 56: Bandit severity mapping
query II
SELECT severity, status FROM parse_duck_hunt_log('{"results":[{"filename":"test.py","line_number":1,"test_id":"B101","issue_severity":"HIGH","issue_text":"High severity"},{"filename":"test.py","line_number":2,"test_id":"B102","issue_severity":"MEDIUM","issue_text":"Medium severity"},{"filename":"test.py","line_number":3,"test_id":"B103","issue_severity":"LOW","issue_text":"Low severity"}]}', 'bandit_json')
ORDER BY event_id;
----
HIGH	ERROR
MEDIUM	WARNING
LOW	INFO

# Test 57: Bandit event type and category validation
query II
SELECT DISTINCT event_type, category FROM parse_duck_hunt_log('{"results":[{"filename":"test.py","line_number":1,"test_id":"B101","issue_severity":"HIGH","issue_text":"Security issue"}]}', 'bandit_json');
----
security_finding	security

# Test 58: Bandit CWE suggestion extraction
query I
SELECT suggestion FROM parse_duck_hunt_log('{"results":[{"filename":"test.py","line_number":1,"test_id":"B608","issue_severity":"HIGH","issue_text":"SQL injection","issue_cwe":{"id":89,"link":"https://cwe.mitre.org/data/definitions/89.html"}}]}', 'bandit_json');
----
CWE-89: https://cwe.mitre.org/data/definitions/89.html

# Test 59: Bandit function name extraction
query I
SELECT function_name FROM parse_duck_hunt_log('{"results":[{"filename":"test.py","line_number":1,"test_id":"B101","test_name":"hardcoded_password_funcarg","issue_severity":"HIGH","issue_text":"Hardcoded password"}]}', 'bandit_json');
----
hardcoded_password_funcarg

# Test 60: SpotBugs JSON format parsing
statement ok
CREATE TABLE spotbugs_results AS 
SELECT * FROM read_duck_hunt_log('workspace/spotbugs_sample.json', 'spotbugs_json');

# Verify SpotBugs parsing results
query IIIII
SELECT COUNT(*), tool_name,
       COUNT(CASE WHEN status = 'ERROR' THEN 1 END) as errors,
       COUNT(CASE WHEN status = 'WARNING' THEN 1 END) as warnings,
       COUNT(CASE WHEN status = 'INFO' THEN 1 END) as info
FROM spotbugs_results
GROUP BY tool_name;
----
4	spotbugs	1	2	1

# Test 61: SpotBugs auto-detection
query I
SELECT DISTINCT tool_name FROM parse_duck_hunt_log('{"BugCollection":{"BugInstance":[{"type":"NP_NULL_ON_SOME_PATH","priority":"2","category":"CORRECTNESS","ShortMessage":"Null pointer dereference"}]}}', 'auto');
----
spotbugs

# Test 62: SpotBugs field validation
query IIII
SELECT ref_file, ref_line, error_code, category
FROM parse_duck_hunt_log('{"BugCollection":{"BugInstance":[{"type":"SQL_NONCONSTANT_STRING_PASSED_TO_EXECUTE","priority":"1","category":"SECURITY","ShortMessage":"SQL injection","SourceLine":{"sourcepath":"com/example/Database.java","start":"45","primary":true}}]}}', 'spotbugs_json');
----
com/example/Database.java	45	SQL_NONCONSTANT_STRING_PASSED_TO_EXECUTE	security

# Test 63: SpotBugs priority mapping
query II
SELECT severity, status FROM parse_duck_hunt_log('{"BugCollection":{"BugInstance":[{"type":"HIGH_PRIORITY","priority":"1","category":"SECURITY","ShortMessage":"High"},{"type":"MED_PRIORITY","priority":"2","category":"CORRECTNESS","ShortMessage":"Medium"},{"type":"LOW_PRIORITY","priority":"3","category":"BAD_PRACTICE","ShortMessage":"Low"}]}}', 'spotbugs_json')
ORDER BY event_id;
----
1	ERROR
2	WARNING
3	INFO

# Test 64: SpotBugs category mapping to event types
query II
SELECT category, event_type FROM parse_duck_hunt_log('{"BugCollection":{"BugInstance":[{"type":"SEC_BUG","priority":"1","category":"SECURITY","ShortMessage":"Security issue"},{"type":"PERF_BUG","priority":"2","category":"PERFORMANCE","ShortMessage":"Performance issue"},{"type":"CORRECT_BUG","priority":"2","category":"CORRECTNESS","ShortMessage":"Correctness issue"},{"type":"PRACTICE_BUG","priority":"3","category":"BAD_PRACTICE","ShortMessage":"Bad practice"}]}}', 'spotbugs_json')
ORDER BY event_id;
----
security	security_finding
performance	performance_issue
correctness	lint_issue
code_quality	lint_issue

# Test 65: SpotBugs function name extraction
query I
SELECT function_name FROM parse_duck_hunt_log('{"BugCollection":{"BugInstance":[{"type":"NP_NULL","priority":"2","category":"CORRECTNESS","ShortMessage":"Null pointer","Method":{"classname":"com.example.Service","name":"processData","primary":true}}]}}', 'spotbugs_json');
----
com.example.Service.processData

# Test 66: SpotBugs suggestion extraction from LongMessage
query I
SELECT suggestion FROM parse_duck_hunt_log('{"BugCollection":{"BugInstance":[{"type":"NP_NULL","priority":"2","category":"CORRECTNESS","ShortMessage":"Null pointer","LongMessage":"Possible null pointer dereference of user in com.example.Service.processData(User)"}]}}', 'spotbugs_json');
----
Possible null pointer dereference of user in com.example.Service.processData(User)

# Test 67: ktlint JSON format parsing
statement ok
CREATE TABLE ktlint_results AS 
SELECT * FROM read_duck_hunt_log('workspace/ktlint_sample.json', 'ktlint_json');

# Verify ktlint parsing results
query IIII
SELECT COUNT(*), tool_name,
       COUNT(CASE WHEN status = 'ERROR' THEN 1 END) as errors,
       COUNT(CASE WHEN status = 'WARNING' THEN 1 END) as warnings
FROM ktlint_results
GROUP BY tool_name;
----
9	ktlint	2	7

# Test 68: ktlint auto-detection
query I
SELECT DISTINCT tool_name FROM parse_duck_hunt_log('[{"file":"Test.kt","errors":[{"line":1,"column":1,"message":"Missing newline","rule":"final-newline"}]}]', 'auto');
----
ktlint

# Test 69: ktlint field validation
query IIIII
SELECT ref_file, ref_line, ref_column, error_code, category
FROM parse_duck_hunt_log('[{"file":"src/main/kotlin/Example.kt","errors":[{"line":15,"column":25,"message":"Unnecessary semicolon","rule":"no-semi"}]}]', 'ktlint_json');
----
src/main/kotlin/Example.kt	15	25	no-semi	code_style

# Test 70: ktlint rule-based severity mapping
query II
SELECT error_code, status FROM parse_duck_hunt_log('[{"file":"Test.kt","errors":[{"line":1,"column":1,"message":"Missing newline at end of file","rule":"final-newline"},{"line":2,"column":1,"message":"Line too long","rule":"max-line-length"},{"line":3,"column":1,"message":"Wrong indentation","rule":"indent"}]}]', 'ktlint_json')
ORDER BY event_id;
----
final-newline	ERROR
max-line-length	WARNING
indent	ERROR

# Test 71: ktlint event type validation
query I
SELECT DISTINCT event_type FROM parse_duck_hunt_log('[{"file":"Test.kt","errors":[{"line":1,"column":1,"message":"Style issue","rule":"style-rule"}]}]', 'ktlint_json');
----
lint_issue

# Test 72: ktlint category validation
query I
SELECT DISTINCT category FROM parse_duck_hunt_log('[{"file":"Test.kt","errors":[{"line":1,"column":1,"message":"Style issue","rule":"style-rule"}]}]', 'ktlint_json');
----
code_style

# Test 73: ktlint multi-file parsing
query II
SELECT ref_file, COUNT(*) as error_count FROM parse_duck_hunt_log('[{"file":"File1.kt","errors":[{"line":1,"column":1,"message":"Error 1","rule":"rule1"}]},{"file":"File2.kt","errors":[{"line":2,"column":2,"message":"Error 2","rule":"rule2"},{"line":3,"column":3,"message":"Error 3","rule":"rule3"}]}]', 'ktlint_json')
GROUP BY ref_file ORDER BY ref_file;
----
File1.kt	1
File2.kt	2

# Test 74: hadolint JSON format parsing
statement ok
CREATE TABLE hadolint_results AS 
SELECT * FROM read_duck_hunt_log('workspace/hadolint_sample.json', 'hadolint_json');

# Verify hadolint parsing results
query IIIII
SELECT COUNT(*), tool_name,
       COUNT(CASE WHEN status = 'ERROR' THEN 1 END) as errors,
       COUNT(CASE WHEN status = 'WARNING' THEN 1 END) as warnings,
       COUNT(CASE WHEN status = 'INFO' THEN 1 END) as info
FROM hadolint_results
GROUP BY tool_name;
----
10	hadolint	4	4	2

# Test 75: hadolint auto-detection
query I
SELECT DISTINCT tool_name FROM parse_duck_hunt_log('[{"file":"Dockerfile","line":1,"column":1,"level":"error","code":"DL3006","message":"Always tag the version"}]', 'auto');
----
hadolint

# Test 76: hadolint field validation
query IIIII
SELECT ref_file, ref_line, ref_column, error_code, category
FROM parse_duck_hunt_log('[{"file":"Dockerfile","line":5,"column":1,"level":"warning","code":"DL3008","message":"Pin versions in apt get install"}]', 'hadolint_json');
----
Dockerfile	5	1	DL3008	dockerfile

# Test 77: hadolint level mapping
query II
SELECT severity, status FROM parse_duck_hunt_log('[{"file":"Dockerfile","line":1,"column":1,"level":"error","code":"DL1","message":"Error"},{"file":"Dockerfile","line":2,"column":1,"level":"warning","code":"DL2","message":"Warning"},{"file":"Dockerfile","line":3,"column":1,"level":"info","code":"DL3","message":"Info"},{"file":"Dockerfile","line":4,"column":1,"level":"style","code":"DL4","message":"Style"}]', 'hadolint_json')
ORDER BY event_id;
----
error	ERROR
warning	WARNING
info	INFO
style	WARNING

# Test 78: hadolint event type validation
query I
SELECT DISTINCT event_type FROM parse_duck_hunt_log('[{"file":"Dockerfile","line":1,"column":1,"level":"error","code":"DL3006","message":"Docker issue"}]', 'hadolint_json');
----
lint_issue

# Test 79: hadolint category validation
query I
SELECT DISTINCT category FROM parse_duck_hunt_log('[{"file":"Dockerfile","line":1,"column":1,"level":"error","code":"DL3006","message":"Docker issue"}]', 'hadolint_json');
----
dockerfile

# Test 80: hadolint multi-file Docker project
query II
SELECT ref_file, COUNT(*) as issue_count FROM parse_duck_hunt_log('[{"file":"Dockerfile","line":1,"column":1,"level":"error","code":"DL3006","message":"Issue 1"},{"file":"Dockerfile.prod","line":2,"column":1,"level":"warning","code":"DL3008","message":"Issue 2"},{"file":"docker/app/Dockerfile","line":3,"column":1,"level":"info","code":"DL3009","message":"Issue 3"}]', 'hadolint_json')
GROUP BY ref_file ORDER BY ref_file;
----
Dockerfile	1
Dockerfile.prod	1
docker/app/Dockerfile	1

# Test 81: lintr JSON format parsing
statement ok
CREATE TABLE lintr_results AS 
SELECT * FROM read_duck_hunt_log('workspace/lintr_sample.json', 'lintr_json');

# Verify lintr parsing results
query IIII
SELECT COUNT(*), tool_name,
       COUNT(CASE WHEN status = 'ERROR' THEN 1 END) as errors,
       COUNT(CASE WHEN status = 'WARNING' THEN 1 END) as warnings
FROM lintr_results
GROUP BY tool_name;
----
10	lintr	2	8

# Test 82: lintr auto-detection
query I
SELECT DISTINCT tool_name FROM parse_duck_hunt_log('[{"filename":"test.R","line_number":1,"column_number":1,"type":"style","message":"Use snake_case","linter":"object_name_linter"}]', 'auto');
----
lintr

# Test 83: lintr field validation
query IIIII
SELECT ref_file, ref_line, ref_column, error_code, category
FROM parse_duck_hunt_log('[{"filename":"analysis/script.R","line_number":15,"column_number":8,"type":"warning","message":"Line too long","linter":"line_length_linter"}]', 'lintr_json');
----
analysis/script.R	15	8	line_length_linter	r_code_style

# Test 84: lintr type mapping
query II
SELECT severity, status FROM parse_duck_hunt_log('[{"filename":"test.R","line_number":1,"column_number":1,"type":"error","message":"Error","linter":"test1"},{"filename":"test.R","line_number":2,"column_number":1,"type":"warning","message":"Warning","linter":"test2"},{"filename":"test.R","line_number":3,"column_number":1,"type":"style","message":"Style","linter":"test3"}]', 'lintr_json')
ORDER BY event_id;
----
error	ERROR
warning	WARNING
style	WARNING

# Test 85: lintr event type validation
query I
SELECT DISTINCT event_type FROM parse_duck_hunt_log('[{"filename":"test.R","line_number":1,"column_number":1,"type":"style","message":"R style issue","linter":"style_linter"}]', 'lintr_json');
----
lint_issue

# Test 86: lintr category validation
query I
SELECT DISTINCT category FROM parse_duck_hunt_log('[{"filename":"test.R","line_number":1,"column_number":1,"type":"style","message":"R style issue","linter":"style_linter"}]', 'lintr_json');
----
r_code_style

# Test 87: lintr code suggestion extraction
query I
SELECT suggestion FROM parse_duck_hunt_log('[{"filename":"test.R","line_number":1,"column_number":1,"type":"style","message":"Use snake_case","linter":"object_name_linter","line":"calculateMean <- function(x) {"}]', 'lintr_json');
----
Code: calculateMean <- function(x) {

# Test 88: lintr multi-file R project
query II
SELECT ref_file, COUNT(*) as issue_count FROM parse_duck_hunt_log('[{"filename":"analysis/data.R","line_number":1,"column_number":1,"type":"style","message":"Issue 1","linter":"linter1"},{"filename":"models/regression.R","line_number":2,"column_number":2,"type":"warning","message":"Issue 2","linter":"linter2"},{"filename":"utils/helpers.R","line_number":3,"column_number":3,"type":"error","message":"Issue 3","linter":"linter3"}]', 'lintr_json')
GROUP BY ref_file ORDER BY ref_file;
----
analysis/data.R	1
models/regression.R	1
utils/helpers.R	1

# Test 89: sqlfluff JSON format parsing
statement ok
CREATE TABLE sqlfluff_results AS 
SELECT * FROM read_duck_hunt_log('workspace/sqlfluff_sample.json', 'sqlfluff_json');

# Verify sqlfluff parsing results
query III
SELECT COUNT(*), tool_name, COUNT(CASE WHEN status = 'WARNING' THEN 1 END) as warnings
FROM sqlfluff_results
GROUP BY tool_name;
----
13	sqlfluff	13

# Test 90: sqlfluff auto-detection
query I
SELECT DISTINCT tool_name FROM parse_duck_hunt_log('[{"filepath":"test.sql","violations":[{"line_no":1,"line_pos":1,"code":"L003","description":"Expected indentation","rule":"indentation"}]}]', 'auto');
----
sqlfluff

# Test 91: sqlfluff field validation
query IIIII
SELECT ref_file, ref_line, ref_column, error_code, category
FROM parse_duck_hunt_log('[{"filepath":"queries/analytics.sql","violations":[{"line_no":10,"line_pos":5,"code":"L010","description":"Keywords must be consistently upper case","rule":"capitalisation.keywords"}]}]', 'sqlfluff_json');
----
queries/analytics.sql	10	5	L010	sql_style

# Test 92: sqlfluff violation parsing
query II
SELECT error_code, function_name FROM parse_duck_hunt_log('[{"filepath":"test.sql","violations":[{"line_no":1,"line_pos":1,"code":"L003","description":"Indentation issue","rule":"indentation"}]}]', 'sqlfluff_json');
----
L003	indentation

# Test 93: sqlfluff event type validation
query I
SELECT DISTINCT event_type FROM parse_duck_hunt_log('[{"filepath":"test.sql","violations":[{"line_no":1,"line_pos":1,"code":"L003","description":"SQL style issue","rule":"indentation"}]}]', 'sqlfluff_json');
----
lint_issue

# Test 94: sqlfluff category validation
query I
SELECT DISTINCT category FROM parse_duck_hunt_log('[{"filepath":"test.sql","violations":[{"line_no":1,"line_pos":1,"code":"L003","description":"SQL style issue","rule":"indentation"}]}]', 'sqlfluff_json');
----
sql_style

# Test 95: sqlfluff suggestion extraction
query I
SELECT suggestion FROM parse_duck_hunt_log('[{"filepath":"test.sql","violations":[{"line_no":1,"line_pos":1,"code":"L003","description":"Indentation issue","rule":"indentation"}]}]', 'sqlfluff_json');
----
Rule: indentation

# Test 96: sqlfluff multi-file SQL project
query II
SELECT ref_file, COUNT(*) as violation_count FROM parse_duck_hunt_log('[{"filepath":"queries/users.sql","violations":[{"line_no":1,"line_pos":1,"code":"L001","description":"Issue 1","rule":"rule1"}]},{"filepath":"migrations/schema.sql","violations":[{"line_no":2,"line_pos":2,"code":"L002","description":"Issue 2","rule":"rule2"},{"line_no":3,"line_pos":3,"code":"L003","description":"Issue 3","rule":"rule3"}]}]', 'sqlfluff_json')
GROUP BY ref_file ORDER BY ref_file;
----
migrations/schema.sql	2
queries/users.sql	1

# Test 97: sqlfluff with no violations
query I
SELECT COUNT(*) FROM parse_duck_hunt_log('[{"filepath":"clean.sql","violations":[]}]', 'sqlfluff_json');
----
0

# Test 98: tflint JSON format parsing
statement ok
CREATE TABLE tflint_results AS 
SELECT * FROM read_duck_hunt_log('workspace/tflint_sample.json', 'tflint_json');

# Verify tflint parsing results
query IIIII
SELECT COUNT(*), tool_name,
       COUNT(CASE WHEN status = 'ERROR' THEN 1 END) as errors,
       COUNT(CASE WHEN status = 'WARNING' THEN 1 END) as warnings,
       COUNT(CASE WHEN status = 'INFO' THEN 1 END) as info
FROM tflint_results
GROUP BY tool_name;
----
10	tflint	3	5	2

# Test 99: tflint auto-detection
query I
SELECT DISTINCT tool_name FROM parse_duck_hunt_log('{"issues":[{"rule":{"name":"terraform_deprecated_interpolation","severity":"warning"},"message":"Test issue","range":{"filename":"main.tf","start":{"line":1,"column":1}}}],"errors":[]}', 'auto');
----
tflint

# Test 100: tflint field validation
query IIIII
SELECT ref_file, ref_line, ref_column, error_code, category
FROM parse_duck_hunt_log('{"issues":[{"rule":{"name":"aws_instance_invalid_type","severity":"error"},"message":"Invalid instance type","range":{"filename":"main.tf","start":{"line":10,"column":5}}}]}', 'tflint_json');
----
main.tf	10	5	aws_instance_invalid_type	infrastructure

# Test 101: tflint severity mapping
query II
SELECT severity, status FROM parse_duck_hunt_log('{"issues":[{"rule":{"name":"test_error","severity":"error"},"message":"Error issue","range":{"filename":"test.tf","start":{"line":1,"column":1}}},{"rule":{"name":"test_warning","severity":"warning"},"message":"Warning issue","range":{"filename":"test.tf","start":{"line":2,"column":1}}},{"rule":{"name":"test_notice","severity":"notice"},"message":"Notice issue","range":{"filename":"test.tf","start":{"line":3,"column":1}}}]}', 'tflint_json')
ORDER BY event_id;
----
error	ERROR
warning	WARNING
notice	INFO

# Test 102: tflint event type validation
query I
SELECT DISTINCT event_type FROM parse_duck_hunt_log('{"issues":[{"rule":{"name":"terraform_issue","severity":"warning"},"message":"Terraform issue","range":{"filename":"main.tf","start":{"line":1,"column":1}}}]}', 'tflint_json');
----
lint_issue

# Test 103: tflint category validation
query I
SELECT DISTINCT category FROM parse_duck_hunt_log('{"issues":[{"rule":{"name":"terraform_issue","severity":"warning"},"message":"Terraform issue","range":{"filename":"main.tf","start":{"line":1,"column":1}}}]}', 'tflint_json');
----
infrastructure

# Test 104: tflint suggestion extraction
query I
SELECT suggestion FROM parse_duck_hunt_log('{"issues":[{"rule":{"name":"terraform_deprecated_interpolation","severity":"warning"},"message":"Use new syntax","range":{"filename":"main.tf","start":{"line":1,"column":1}}}]}', 'tflint_json');
----
Rule: terraform_deprecated_interpolation

# Test 105: tflint multi-file Terraform project
query II
SELECT ref_file, COUNT(*) as issue_count FROM parse_duck_hunt_log('{"issues":[{"rule":{"name":"rule1","severity":"error"},"message":"Issue 1","range":{"filename":"main.tf","start":{"line":1,"column":1}}},{"rule":{"name":"rule2","severity":"warning"},"message":"Issue 2","range":{"filename":"variables.tf","start":{"line":2,"column":2}}},{"rule":{"name":"rule3","severity":"notice"},"message":"Issue 3","range":{"filename":"variables.tf","start":{"line":3,"column":3}}}]}', 'tflint_json')
GROUP BY ref_file ORDER BY ref_file;
----
main.tf	1
variables.tf	2

# Test 106: tflint with no issues
query I
SELECT COUNT(*) FROM parse_duck_hunt_log('{"issues":[],"errors":[]}', 'tflint_json');
----
0

# Test 107: kube-score JSON format parsing
statement ok
CREATE TABLE kube_score_results AS 
SELECT * FROM read_duck_hunt_log('workspace/kube_score_sample.json', 'kube_score_json');

# Verify kube-score parsing results
query IIII
SELECT COUNT(*), tool_name,
       COUNT(CASE WHEN status = 'ERROR' THEN 1 END) as errors,
       COUNT(CASE WHEN status = 'WARNING' THEN 1 END) as warnings
FROM kube_score_results
GROUP BY tool_name;
----
10	kube-score	3	7

# Test 108: kube-score auto-detection
query I
SELECT DISTINCT tool_name FROM parse_duck_hunt_log('[{"object_name":"test-app","type_meta":{"kind":"Deployment"},"file_name":"test.yaml","checks":[{"check":{"id":"container-resources","name":"Container Resources"},"grade":"WARNING","comments":[{"summary":"Resource limits not set"}]}]}]', 'auto');
----
kube-score

# Test 109: kube-score field validation
query IIIII
SELECT ref_file, ref_line, error_code, category, function_name
FROM parse_duck_hunt_log('[{"object_name":"my-app","type_meta":{"kind":"Deployment"},"file_name":"deployment.yaml","file_row":5,"checks":[{"check":{"id":"container-security-context","name":"Container Security"},"grade":"CRITICAL","comments":[{"summary":"Container runs as root"}]}]}]', 'kube_score_json');
----
deployment.yaml	5	container-security-context	kubernetes	my-app (Deployment)

# Test 110: kube-score severity mapping
query II
SELECT severity, status FROM parse_duck_hunt_log('[{"object_name":"test","type_meta":{"kind":"Pod"},"file_name":"test.yaml","checks":[{"check":{"id":"test1"},"grade":"CRITICAL","comments":[{"summary":"Critical issue"}]},{"check":{"id":"test2"},"grade":"WARNING","comments":[{"summary":"Warning issue"}]}]}]', 'kube_score_json')
ORDER BY event_id;
----
critical	ERROR
warning	WARNING

# Test 111: kube-score event type validation
query I
SELECT DISTINCT event_type FROM parse_duck_hunt_log('[{"object_name":"test","type_meta":{"kind":"Service"},"file_name":"test.yaml","checks":[{"check":{"id":"service-check"},"grade":"WARNING","comments":[{"summary":"K8s issue"}]}]}]', 'kube_score_json');
----
lint_issue

# Test 112: kube-score category validation
query I
SELECT DISTINCT category FROM parse_duck_hunt_log('[{"object_name":"test","type_meta":{"kind":"Deployment"},"file_name":"test.yaml","checks":[{"check":{"id":"k8s-check"},"grade":"WARNING","comments":[{"summary":"Kubernetes issue"}]}]}]', 'kube_score_json');
----
kubernetes

# Test 113: kube-score suggestion extraction
query I
SELECT suggestion FROM parse_duck_hunt_log('[{"object_name":"test","type_meta":{"kind":"Pod"},"file_name":"test.yaml","checks":[{"check":{"id":"test-check"},"grade":"WARNING","comments":[{"summary":"Issue summary","description":"Detailed description of the issue"}]}]}]', 'kube_score_json');
----
Detailed description of the issue

# Test 114: kube-score multi-resource Kubernetes project
query II
SELECT function_name, COUNT(*) as issue_count FROM parse_duck_hunt_log('[{"object_name":"app","type_meta":{"kind":"Deployment"},"file_name":"app.yaml","checks":[{"check":{"id":"check1"},"grade":"WARNING","comments":[{"summary":"Issue 1"}]}]},{"object_name":"svc","type_meta":{"kind":"Service"},"file_name":"service.yaml","checks":[{"check":{"id":"check2"},"grade":"CRITICAL","comments":[{"summary":"Issue 2"},{"summary":"Issue 3"}]}]}]', 'kube_score_json')
GROUP BY function_name ORDER BY function_name;
----
app (Deployment)	1
svc (Service)	2

# Test 115: kube-score with path information
query I
SELECT test_name FROM parse_duck_hunt_log('[{"object_name":"test","type_meta":{"kind":"Pod"},"file_name":"test.yaml","checks":[{"check":{"id":"test-check"},"grade":"WARNING","comments":[{"path":"spec.containers[0].resources","summary":"Resource issue"}]}]}]', 'kube_score_json');
----
spec.containers[0].resources

# Test 116: kube-score with no issues (only OK checks)
query I
SELECT COUNT(*) FROM parse_duck_hunt_log('[{"object_name":"clean-app","type_meta":{"kind":"Deployment"},"file_name":"clean.yaml","checks":[{"check":{"id":"test-check"},"grade":"OK","comments":[]}]}]', 'kube_score_json');
----
0

# Test 117: CMake build output parsing
statement ok
CREATE TABLE cmake_results AS 
SELECT * FROM read_duck_hunt_log('workspace/cmake_sample.txt', 'cmake_build');

# Verify CMake parsing results
query IIII
SELECT COUNT(*), tool_name,
       COUNT(CASE WHEN status = 'ERROR' THEN 1 END) as errors,
       COUNT(CASE WHEN status = 'WARNING' THEN 1 END) as warnings
FROM cmake_results
GROUP BY tool_name;
----
24	cmake	19	5

# Test 118: CMake auto-detection
query I
SELECT DISTINCT tool_name FROM parse_duck_hunt_log('CMake Error at CMakeLists.txt:25 (find_package):
Could not find package
gmake[1]: *** [all] Error 2
Building CXX object main.cpp.o', 'auto');
----
cmake

# Test 119: CMake compilation error parsing
query IIIII
SELECT ref_file, ref_line, ref_column, category, severity
FROM parse_duck_hunt_log('/home/user/src/main.cpp:15:10: error: iostream file not found', 'cmake_build');
----
/home/user/src/main.cpp	15	10	compilation	error

# Test 120: CMake configuration error parsing
query IIII
SELECT ref_file, ref_line, category, message LIKE '%Could not find%' as has_package_error
FROM parse_duck_hunt_log('CMake Error at CMakeLists.txt:25 (find_package):
  Could not find a package configuration file provided by "Boost"', 'cmake_build');
----
CMakeLists.txt	25	configuration	true

# Test 121: CMake linker error parsing
query III
SELECT function_name, category, suggestion LIKE '%Link the library%' as has_suggestion
FROM parse_duck_hunt_log('/usr/bin/ld: database.cpp: undefined reference to `mysql_init`', 'cmake_build');
----
mysql_init	linking	true

# Test 122: CMake severity mapping
query II
SELECT category, status FROM parse_duck_hunt_log('/home/test.cpp:10:5: error: syntax error
/home/test.cpp:15:8: warning: unused variable
CMake Error at CMakeLists.txt:10:
CMake Warning at CMakeLists.txt:20:', 'cmake_build')
ORDER BY event_id;
----
compilation	ERROR
compilation	WARNING
configuration	ERROR
configuration	WARNING

# Test 122b: CMake warning variants (Deprecation Warning, Developer Warning)
query III
SELECT status, category, message LIKE '%Deprecation%' as is_deprecation FROM parse_duck_hunt_log('CMake Deprecation Warning at /home/test/CMakeLists.txt:1 (cmake_minimum_required):
  Compatibility with CMake < 3.10 will be removed
CMake Developer Warning at /home/test/CMakeLists.txt:5:
  Some developer warning message
CMake Warning at /home/test/CMakeLists.txt:10:
  Standard warning message', 'cmake_build')
ORDER BY event_id;
----
WARNING	configuration	true
WARNING	configuration	false
WARNING	configuration	false

# Test 123: CMake event type validation
query I
SELECT DISTINCT event_type FROM parse_duck_hunt_log('/home/test.cpp:10:5: error: build failed', 'cmake_build');
----
build_error

# Test 124: CMake category validation
query I
SELECT DISTINCT category FROM parse_duck_hunt_log('/home/test.cpp:10:5: error: compilation failed
/usr/bin/ld: undefined reference to test
CMake Error at CMakeLists.txt:10:
gmake[1]: *** [all] Error 2', 'cmake_build')
ORDER BY category;
----
build_failure
compilation
configuration
linking

# Test 125: CMake multi-file project errors
query II
SELECT ref_file, COUNT(*) as error_count FROM parse_duck_hunt_log('/home/main.cpp:10:5: error: syntax error
/home/utils.cpp:15:8: warning: unused variable
/home/config.cpp:20:1: error: missing semicolon', 'cmake_build')
WHERE ref_file IS NOT NULL
GROUP BY ref_file ORDER BY ref_file;
----
/home/config.cpp	1
/home/main.cpp	1
/home/utils.cpp	1

# ============================================================================
# File-based sqlfluff tests (Tests 126-131)
# ============================================================================

# Test 126: sqlfluff file-based parsing - total count
query II
SELECT COUNT(*), tool_name
FROM read_duck_hunt_log('test/samples/linting_tools/sqlfluff_output.json', 'sqlfluff_json')
GROUP BY tool_name;
----
22	sqlfluff

# Test 127: sqlfluff file-based parsing - violations by file
query II
SELECT ref_file, COUNT(*) as violation_count
FROM read_duck_hunt_log('test/samples/linting_tools/sqlfluff_output.json', 'sqlfluff_json')
GROUP BY ref_file
ORDER BY violation_count DESC, ref_file
LIMIT 5;
----
dbt/models/marts/fct_sales.sql	3
migrations/2024/001_create_users.sql	3
queries/analytics/user_engagement.sql	3
views/dashboard/monthly_summary.sql	3
dbt/models/staging/stg_customers.sql	2

# Test 128: sqlfluff file-based parsing - distinct file count
query I
SELECT COUNT(DISTINCT ref_file)
FROM read_duck_hunt_log('test/samples/linting_tools/sqlfluff_output.json', 'sqlfluff_json');
----
10

# Test 129: sqlfluff file-based parsing - rule extraction
query II
SELECT error_code, function_name
FROM read_duck_hunt_log('test/samples/linting_tools/sqlfluff_output.json', 'sqlfluff_json')
WHERE ref_file = 'queries/analytics/user_engagement.sql'
ORDER BY ref_line;
----
L003	indentation
L010	capitalisation.keywords
L014	capitalisation.identifiers

# Test 130: sqlfluff file-based parsing - all warnings status
query I
SELECT COUNT(*) = 22
FROM read_duck_hunt_log('test/samples/linting_tools/sqlfluff_output.json', 'sqlfluff_json')
WHERE status = 'WARNING';
----
true

# Test 131: sqlfluff file-based parsing - log_file tracking
query I
SELECT DISTINCT log_file
FROM read_duck_hunt_log('test/samples/linting_tools/sqlfluff_output.json', 'sqlfluff_json');
----
test/samples/linting_tools/sqlfluff_output.json

# ============================================================================
# File-based lintr tests (Tests 132-137)
# ============================================================================

# Test 132: lintr file-based parsing - total count and severity breakdown
query III
SELECT COUNT(*),
       SUM(CASE WHEN status='ERROR' THEN 1 ELSE 0 END) as errors,
       SUM(CASE WHEN status='WARNING' THEN 1 ELSE 0 END) as warnings
FROM read_duck_hunt_log('test/samples/linting_tools/lintr_output.json', 'lintr_json');
----
20	2	18

# Test 133: lintr file-based parsing - issues by file
query II
SELECT ref_file, COUNT(*) as issue_count
FROM read_duck_hunt_log('test/samples/linting_tools/lintr_output.json', 'lintr_json')
GROUP BY ref_file
ORDER BY issue_count DESC, ref_file
LIMIT 5;
----
models/regression_analysis.R	4
R/package_functions.R	3
analysis/data_processing.R	3
scripts/etl_pipeline.R	3
tests/test_models.R	3

# Test 134: lintr file-based parsing - distinct file count
query I
SELECT COUNT(DISTINCT ref_file)
FROM read_duck_hunt_log('test/samples/linting_tools/lintr_output.json', 'lintr_json');
----
7

# Test 135: lintr file-based parsing - linter extraction
query II
SELECT error_code, severity
FROM read_duck_hunt_log('test/samples/linting_tools/lintr_output.json', 'lintr_json')
WHERE ref_file = 'models/regression_analysis.R'
ORDER BY ref_line;
----
namespace_linter	error
infix_spaces_linter	style
trailing_whitespace_linter	style
sapply_linter	warning

# Test 136: lintr file-based parsing - line content as suggestion
query I
SELECT COUNT(*) > 0
FROM read_duck_hunt_log('test/samples/linting_tools/lintr_output.json', 'lintr_json')
WHERE suggestion LIKE 'Code:%';
----
true

# Test 137: lintr file-based parsing - tool_name and category
query II
SELECT DISTINCT tool_name, category
FROM read_duck_hunt_log('test/samples/linting_tools/lintr_output.json', 'lintr_json');
----
lintr	r_code_style

# ============================================================================
# File-based spotbugs tests (Tests 138-143)
# ============================================================================

# Test 138: spotbugs file-based parsing - total count and severity breakdown
query IIII
SELECT COUNT(*),
       SUM(CASE WHEN status='ERROR' THEN 1 ELSE 0 END) as errors,
       SUM(CASE WHEN status='WARNING' THEN 1 ELSE 0 END) as warnings,
       SUM(CASE WHEN status='INFO' THEN 1 ELSE 0 END) as info
FROM read_duck_hunt_log('test/samples/linting_tools/spotbugs_output.json', 'spotbugs_json');
----
15	3	8	4

# Test 139: spotbugs file-based parsing - category distribution
query II
SELECT category, COUNT(*) as cnt
FROM read_duck_hunt_log('test/samples/linting_tools/spotbugs_output.json', 'spotbugs_json')
GROUP BY category
ORDER BY cnt DESC, category;
----
correctness	5
code_quality	4
performance	3
security	3

# Test 140: spotbugs file-based parsing - distinct file count
query I
SELECT COUNT(DISTINCT ref_file)
FROM read_duck_hunt_log('test/samples/linting_tools/spotbugs_output.json', 'spotbugs_json');
----
15

# Test 141: spotbugs file-based parsing - security findings
query II
SELECT error_code, ref_file
FROM read_duck_hunt_log('test/samples/linting_tools/spotbugs_output.json', 'spotbugs_json')
WHERE category = 'security'
ORDER BY ref_line;
----
SQL_INJECTION_JDBC	com/example/dao/UserDao.java
PATH_TRAVERSAL_IN	com/example/io/FileHandler.java
XSS_SERVLET	com/example/web/UserServlet.java

# Test 142: spotbugs file-based parsing - method extraction
query II
SELECT function_name, message
FROM read_duck_hunt_log('test/samples/linting_tools/spotbugs_output.json', 'spotbugs_json')
WHERE function_name IS NOT NULL AND function_name != ''
ORDER BY function_name
LIMIT 3;
----
com.example.cache.CacheManager.processEntries	Inefficient Map iterator
com.example.controller.RequestHandler.processRequest	Unchecked/unconfirmed cast
com.example.dao.UserDao.findByUsername	SQL injection vulnerability

# Test 143: spotbugs file-based parsing - tool_name verification
query II
SELECT DISTINCT tool_name, event_type
FROM read_duck_hunt_log('test/samples/linting_tools/spotbugs_output.json', 'spotbugs_json')
WHERE category = 'security';
----
spotbugs	security_finding

# ============================================================================
# File-based ktlint tests (Tests 144-149)
# ============================================================================

# Test 144: ktlint file-based parsing - total count and severity breakdown
query III
SELECT COUNT(*),
       SUM(CASE WHEN status='ERROR' THEN 1 ELSE 0 END) as errors,
       SUM(CASE WHEN status='WARNING' THEN 1 ELSE 0 END) as warnings
FROM read_duck_hunt_log('test/samples/linting_tools/ktlint_output.json', 'ktlint_json');
----
18	4	14

# Test 145: ktlint file-based parsing - errors by file
query II
SELECT ref_file, COUNT(*) as error_count
FROM read_duck_hunt_log('test/samples/linting_tools/ktlint_output.json', 'ktlint_json')
GROUP BY ref_file
ORDER BY error_count DESC, ref_file
LIMIT 5;
----
src/main/kotlin/com/example/app/MainActivity.kt	3
src/main/kotlin/com/example/app/UserService.kt	3
src/main/kotlin/com/example/app/ui/HomeFragment.kt	3
src/test/kotlin/com/example/app/UserServiceTest.kt	3
src/main/kotlin/com/example/app/data/Repository.kt	2

# Test 146: ktlint file-based parsing - distinct file count
query I
SELECT COUNT(DISTINCT ref_file)
FROM read_duck_hunt_log('test/samples/linting_tools/ktlint_output.json', 'ktlint_json');
----
7

# Test 147: ktlint file-based parsing - rule extraction
query II
SELECT error_code, status
FROM read_duck_hunt_log('test/samples/linting_tools/ktlint_output.json', 'ktlint_json')
WHERE ref_file = 'src/main/kotlin/com/example/app/MainActivity.kt'
ORDER BY ref_line;
----
final-newline	ERROR
no-wildcard-imports	WARNING
indent	ERROR

# Test 148: ktlint file-based parsing - tool_name and category
query II
SELECT DISTINCT tool_name, category
FROM read_duck_hunt_log('test/samples/linting_tools/ktlint_output.json', 'ktlint_json');
----
ktlint	code_style

# Test 149: ktlint file-based parsing - log_file tracking
query I
SELECT DISTINCT log_file
FROM read_duck_hunt_log('test/samples/linting_tools/ktlint_output.json', 'ktlint_json');
----
test/samples/linting_tools/ktlint_output.json

# ============================================================================
# File-based cargo_test tests (Tests 150-155)
# ============================================================================

# Test 150: cargo_test file-based parsing - total count and result breakdown
query IIII
SELECT COUNT(*),
       SUM(CASE WHEN status='PASS' THEN 1 ELSE 0 END) as passed,
       SUM(CASE WHEN status='FAIL' THEN 1 ELSE 0 END) as failed,
       SUM(CASE WHEN status='SKIP' THEN 1 ELSE 0 END) as ignored
FROM read_duck_hunt_log('test/samples/test_frameworks/cargo_test_output.jsonl', 'cargo_test_json');
----
14	10	2	2

# Test 151: cargo_test file-based parsing - tests by module
query II
SELECT split_part(test_name, '::', 1) as module, COUNT(*) as test_count
FROM read_duck_hunt_log('test/samples/test_frameworks/cargo_test_output.jsonl', 'cargo_test_json')
GROUP BY module
ORDER BY test_count DESC, module;
----
db	4
api	3
auth	3
core	3
integration	1

# Test 152: cargo_test file-based parsing - failed tests count
query I
SELECT COUNT(*)
FROM read_duck_hunt_log('test/samples/test_frameworks/cargo_test_output.jsonl', 'cargo_test_json')
WHERE status = 'FAIL';
----
2

# Test 153: cargo_test file-based parsing - execution time
query I
SELECT COUNT(*) > 0
FROM read_duck_hunt_log('test/samples/test_frameworks/cargo_test_output.jsonl', 'cargo_test_json')
WHERE execution_time > 0;
----
true

# Test 154: cargo_test file-based parsing - tool_name and category
query II
SELECT DISTINCT tool_name, category
FROM read_duck_hunt_log('test/samples/test_frameworks/cargo_test_output.jsonl', 'cargo_test_json');
----
cargo_test	test

# Test 155: cargo_test file-based parsing - event_type verification
query I
SELECT DISTINCT event_type
FROM read_duck_hunt_log('test/samples/test_frameworks/cargo_test_output.jsonl', 'cargo_test_json');
----
test_result

# ============================================================================
# File-based hadolint tests (Tests 156-161)
# ============================================================================

# Test 156: hadolint file-based parsing - total count and severity breakdown
query IIII
SELECT COUNT(*),
       SUM(CASE WHEN status='ERROR' THEN 1 ELSE 0 END) as errors,
       SUM(CASE WHEN status='WARNING' THEN 1 ELSE 0 END) as warnings,
       SUM(CASE WHEN status='INFO' THEN 1 ELSE 0 END) as info
FROM read_duck_hunt_log('test/samples/linting_tools/hadolint_output.json', 'hadolint_json');
----
8	1	5	2

# Test 157: hadolint file-based parsing - rule codes
query II
SELECT error_code, severity
FROM read_duck_hunt_log('test/samples/linting_tools/hadolint_output.json', 'hadolint_json')
ORDER BY ref_line;
----
DL3006	warning
DL3008	warning
DL3009	info
DL3020	error
DL3025	warning
DL4006	warning
DL3002	warning
SC2086	info

# Test 158: hadolint file-based parsing - dockerfile reference
query I
SELECT DISTINCT ref_file
FROM read_duck_hunt_log('test/samples/linting_tools/hadolint_output.json', 'hadolint_json');
----
Dockerfile

# Test 159: hadolint file-based parsing - tool_name and category
query II
SELECT DISTINCT tool_name, category
FROM read_duck_hunt_log('test/samples/linting_tools/hadolint_output.json', 'hadolint_json');
----
hadolint	dockerfile

# Test 160: hadolint file-based parsing - shellcheck rules (SC codes)
query I
SELECT COUNT(*)
FROM read_duck_hunt_log('test/samples/linting_tools/hadolint_output.json', 'hadolint_json')
WHERE error_code LIKE 'SC%';
----
1

# Test 161: hadolint file-based parsing - log_file tracking
query I
SELECT DISTINCT log_file
FROM read_duck_hunt_log('test/samples/linting_tools/hadolint_output.json', 'hadolint_json');
----
test/samples/linting_tools/hadolint_output.json

# ============================================================================
# File-based bandit tests (Tests 162-167)
# ============================================================================

# Test 162: bandit file-based parsing - total count and severity
query III
SELECT COUNT(*),
       SUM(CASE WHEN severity = 'HIGH' THEN 1 ELSE 0 END) as high,
       SUM(CASE WHEN severity = 'MEDIUM' THEN 1 ELSE 0 END) as medium
FROM read_duck_hunt_log('test/samples/linting_tools/bandit_output.json', 'bandit_json');
----
5	3	2

# Test 163: bandit file-based parsing - security findings by file
query II
SELECT ref_file, error_code
FROM read_duck_hunt_log('test/samples/linting_tools/bandit_output.json', 'bandit_json')
ORDER BY ref_file;
----
myapp/api/auth.py	B608
myapp/config.py	B105
myapp/services/cache.py	B301
myapp/services/processor.py	B307
myapp/utils/helpers.py	B602

# Test 164: bandit file-based parsing - test_id in structured_data
query I
SELECT COUNT(*) > 0
FROM read_duck_hunt_log('test/samples/linting_tools/bandit_output.json', 'bandit_json')
WHERE structured_data LIKE '%test_id%';
----
true

# Test 165: bandit file-based parsing - tool_name and category
query II
SELECT DISTINCT tool_name, category
FROM read_duck_hunt_log('test/samples/linting_tools/bandit_output.json', 'bandit_json');
----
bandit	security

# Test 166: bandit file-based parsing - event type for security
query I
SELECT DISTINCT event_type
FROM read_duck_hunt_log('test/samples/linting_tools/bandit_output.json', 'bandit_json');
----
security_finding

# Test 167: bandit file-based parsing - log_file tracking
query I
SELECT DISTINCT log_file
FROM read_duck_hunt_log('test/samples/linting_tools/bandit_output.json', 'bandit_json');
----
test/samples/linting_tools/bandit_output.json

# ============================================================================
# File-based shellcheck tests (Tests 168-173)
# ============================================================================

# Test 168: shellcheck file-based parsing - total count
query II
SELECT COUNT(*), COUNT(DISTINCT ref_file)
FROM read_duck_hunt_log('test/samples/linting_tools/shellcheck_output.json', 'shellcheck_json');
----
7	2

# Test 169: shellcheck file-based parsing - issues by file
query II
SELECT ref_file, COUNT(*) as issue_count
FROM read_duck_hunt_log('test/samples/linting_tools/shellcheck_output.json', 'shellcheck_json')
GROUP BY ref_file
ORDER BY ref_file;
----
scripts/backup.sh	3
scripts/deploy.sh	4

# Test 170: shellcheck file-based parsing - severity levels
query II
SELECT severity, COUNT(*) as cnt
FROM read_duck_hunt_log('test/samples/linting_tools/shellcheck_output.json', 'shellcheck_json')
GROUP BY severity
ORDER BY severity;
----
error	2
info	1
style	1
warning	3

# Test 171: shellcheck file-based parsing - tool_name and category
query II
SELECT DISTINCT tool_name, category
FROM read_duck_hunt_log('test/samples/linting_tools/shellcheck_output.json', 'shellcheck_json');
----
shellcheck	shell_script

# Test 172: shellcheck file-based parsing - fix suggestions available
query I
SELECT COUNT(*) > 0
FROM read_duck_hunt_log('test/samples/linting_tools/shellcheck_output.json', 'shellcheck_json')
WHERE suggestion IS NOT NULL AND suggestion != '';
----
true

# Test 173: shellcheck file-based parsing - log_file tracking
query I
SELECT DISTINCT log_file
FROM read_duck_hunt_log('test/samples/linting_tools/shellcheck_output.json', 'shellcheck_json');
----
test/samples/linting_tools/shellcheck_output.json

# ============================================================================
# File-based rubocop tests (Tests 174-179)
# ============================================================================

# Test 174: rubocop file-based parsing - total count and severity
query III
SELECT COUNT(*),
       SUM(CASE WHEN status='ERROR' THEN 1 ELSE 0 END) as errors,
       SUM(CASE WHEN status='WARNING' THEN 1 ELSE 0 END) as warnings
FROM read_duck_hunt_log('test/samples/linting_tools/rubocop_output.json', 'rubocop_json');
----
6	1	5

# Test 175: rubocop file-based parsing - offenses by file
query II
SELECT ref_file, COUNT(*) as offense_count
FROM read_duck_hunt_log('test/samples/linting_tools/rubocop_output.json', 'rubocop_json')
GROUP BY ref_file
ORDER BY offense_count DESC, ref_file;
----
app/controllers/users_controller.rb	3
app/models/user.rb	2
app/services/auth_service.rb	1

# Test 176: rubocop file-based parsing - cop names
query II
SELECT error_code, severity
FROM read_duck_hunt_log('test/samples/linting_tools/rubocop_output.json', 'rubocop_json')
WHERE ref_file = 'app/models/user.rb'
ORDER BY ref_line;
----
Style/Documentation	convention
Lint/UselessAssignment	warning

# Test 177: rubocop file-based parsing - tool_name and category
query II
SELECT DISTINCT tool_name, category
FROM read_duck_hunt_log('test/samples/linting_tools/rubocop_output.json', 'rubocop_json');
----
rubocop	code_quality

# Test 178: rubocop file-based parsing - event_type verification
query I
SELECT DISTINCT event_type
FROM read_duck_hunt_log('test/samples/linting_tools/rubocop_output.json', 'rubocop_json');
----
lint_issue

# Test 179: rubocop file-based parsing - log_file tracking
query I
SELECT DISTINCT log_file
FROM read_duck_hunt_log('test/samples/linting_tools/rubocop_output.json', 'rubocop_json');
----
test/samples/linting_tools/rubocop_output.json

# Clean up
statement ok
DROP TABLE rubocop_results;

statement ok
DROP TABLE cargo_results;

statement ok
DROP TABLE swiftlint_results;

statement ok
DROP TABLE phpstan_results;

statement ok
DROP TABLE shellcheck_results;

statement ok
DROP TABLE stylelint_results;

statement ok
DROP TABLE clippy_results;

statement ok
DROP TABLE markdownlint_results;

statement ok
DROP TABLE yamllint_results;

statement ok
DROP TABLE bandit_results;

statement ok
DROP TABLE spotbugs_results;

statement ok
DROP TABLE ktlint_results;

statement ok
DROP TABLE hadolint_results;

statement ok
DROP TABLE lintr_results;

statement ok
DROP TABLE sqlfluff_results;

statement ok
DROP TABLE tflint_results;

statement ok
DROP TABLE kube_score_results;

statement ok
DROP TABLE cmake_results;