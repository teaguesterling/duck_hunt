# name: test/sql/new_formats.test
# description: test new RuboCop JSON and Cargo test JSON formats
# group: [sql]

require duck_hunt

# Test 1: RuboCop JSON format parsing
statement ok
CREATE TABLE rubocop_results AS 
SELECT * FROM read_duck_hunt_log('workspace/rubocop_sample.json', 'rubocop_json');

# Verify RuboCop parsing results
query IIII
SELECT COUNT(*), tool_name,
       COUNT(CASE WHEN status = 'ERROR' THEN 1 END) as errors,
       COUNT(CASE WHEN status = 'WARNING' THEN 1 END) as warnings
FROM rubocop_results
GROUP BY tool_name;
----
4	rubocop	1	3

# Test 2: Cargo test JSON format parsing
statement ok
CREATE TABLE cargo_results AS 
SELECT * FROM read_duck_hunt_log('workspace/cargo_test_sample.json', 'cargo_test_json');

# Verify Cargo test parsing results
query IIII
SELECT COUNT(*), tool_name,
       COUNT(CASE WHEN status = 'PASS' THEN 1 END) as passes,
       COUNT(CASE WHEN status = 'FAIL' THEN 1 END) as fails
FROM cargo_results
GROUP BY tool_name;
----
4	cargo_test	2	1

# Test 3: RuboCop auto-detection
query I
SELECT DISTINCT tool_name FROM parse_duck_hunt_log('{"files":[{"path":"test.rb","offenses":[{"severity":"error","cop_name":"TestCop","message":"Test message","location":{"start_line":1,"start_column":1}}]}]}', 'auto');
----
rubocop

# Test 4: Cargo test auto-detection
query I
SELECT DISTINCT tool_name FROM parse_duck_hunt_log('{"type":"test","event":"started","name":"test::example"}
{"type":"test","event":"ok","name":"test::example","exec_time":0.001}', 'auto');
----
cargo_test

# Test 5: RuboCop field validation
query IIII
SELECT ref_file, ref_line, error_code, severity
FROM parse_duck_hunt_log('{"files":[{"path":"/src/test.rb","offenses":[{"severity":"convention","cop_name":"Style/TestRule","message":"Test convention","location":{"start_line":5,"start_column":10}}]}]}', 'rubocop_json');
----
/src/test.rb	5	Style/TestRule	convention

# Test 6: Cargo test field validation
query IIII
SELECT test_name, status, execution_time > 0 as has_time, message
FROM parse_duck_hunt_log('{"type":"test","event":"started","name":"module::test_function"}
{"type":"test","event":"failed","name":"module::test_function","exec_time":0.123,"stdout":"assertion failed"}', 'cargo_test_json');
----
module::test_function	FAIL	true	Test failed: assertion failed

# Test 7: RuboCop severity mapping
query II
SELECT severity, status FROM parse_duck_hunt_log('{"files":[{"path":"test.rb","offenses":[{"severity":"error","cop_name":"TestCop","message":"Error msg","location":{"start_line":1,"start_column":1}},{"severity":"warning","cop_name":"TestCop2","message":"Warning msg","location":{"start_line":2,"start_column":1}},{"severity":"convention","cop_name":"TestCop3","message":"Convention msg","location":{"start_line":3,"start_column":1}}]}]}', 'rubocop_json')
ORDER BY event_id;
----
error	ERROR
warning	WARNING
convention	WARNING

# Test 8: Cargo test ignored status
query II
SELECT status, message FROM parse_duck_hunt_log('{"type":"test","event":"started","name":"test::ignored_test"}
{"type":"test","event":"ignored","name":"test::ignored_test","exec_time":0.001}', 'cargo_test_json');
----
SKIP	Test ignored

# Test 9: RuboCop with no offenses
query I
SELECT COUNT(*) FROM parse_duck_hunt_log('{"files":[{"path":"test.rb","offenses":[]}]}', 'rubocop_json');
----
0

# Test 10: Cargo test with failure details
query I
SELECT message LIKE '%assertion failed%' as has_failure_details FROM parse_duck_hunt_log('{"type":"test","event":"started","name":"test::failing"}
{"type":"test","event":"failed","name":"test::failing","exec_time":0.001,"stdout":"assertion failed: expected true"}', 'cargo_test_json');
----
true

# Test 11: RuboCop event type validation
query I
SELECT DISTINCT event_type FROM parse_duck_hunt_log('{"files":[{"path":"test.rb","offenses":[{"severity":"error","cop_name":"TestCop","message":"Test","location":{"start_line":1,"start_column":1}}]}]}', 'rubocop_json');
----
lint_issue

# Test 12: Cargo test event type validation
query I
SELECT DISTINCT event_type FROM parse_duck_hunt_log('{"type":"test","event":"started","name":"test::example"}
{"type":"test","event":"ok","name":"test::example","exec_time":0.001}', 'cargo_test_json');
----
test_result

# Test 13: RuboCop category field
query I
SELECT DISTINCT category FROM parse_duck_hunt_log('{"files":[{"path":"test.rb","offenses":[{"severity":"error","cop_name":"TestCop","message":"Test","location":{"start_line":1,"start_column":1}}]}]}', 'rubocop_json');
----
code_quality

# Test 14: Cargo test category field
query I
SELECT DISTINCT category FROM parse_duck_hunt_log('{"type":"test","event":"started","name":"test::example"}
{"type":"test","event":"ok","name":"test::example","exec_time":0.001}', 'cargo_test_json');
----
test

# Test 15: RuboCop location parsing
query II
SELECT ref_line, ref_column FROM parse_duck_hunt_log('{"files":[{"path":"test.rb","offenses":[{"severity":"error","cop_name":"TestCop","message":"Test","location":{"start_line":15,"start_column":25}}]}]}', 'rubocop_json');
----
15	25

# Test 16: SwiftLint JSON format parsing
statement ok
CREATE TABLE swiftlint_results AS 
SELECT * FROM read_duck_hunt_log('workspace/swiftlint_sample.json', 'swiftlint_json');

# Verify SwiftLint parsing results
query IIII
SELECT COUNT(*), tool_name,
       COUNT(CASE WHEN status = 'ERROR' THEN 1 END) as errors,
       COUNT(CASE WHEN status = 'WARNING' THEN 1 END) as warnings
FROM swiftlint_results
GROUP BY tool_name;
----
5	swiftlint	2	3

# Test 17: PHPStan JSON format parsing
statement ok
CREATE TABLE phpstan_results AS 
SELECT * FROM read_duck_hunt_log('workspace/phpstan_sample.json', 'phpstan_json');

# Verify PHPStan parsing results
query IIII
SELECT COUNT(*), tool_name,
       COUNT(CASE WHEN status = 'ERROR' THEN 1 END) as errors,
       COUNT(CASE WHEN status = 'WARNING' THEN 1 END) as warnings
FROM phpstan_results
GROUP BY tool_name;
----
3	phpstan	2	1

# Test 18: SwiftLint auto-detection
query I
SELECT DISTINCT tool_name FROM parse_duck_hunt_log('[{"file":"test.swift","rule_id":"test_rule","severity":"warning","reason":"Test message","line":1,"column":1}]', 'auto');
----
swiftlint

# Test 19: PHPStan auto-detection
query I
SELECT DISTINCT tool_name FROM parse_duck_hunt_log('{"totals":{"errors":1},"files":{"/test.php":{"errors":1,"messages":[{"message":"Test error","line":1,"ignorable":false}]}}}', 'auto');
----
phpstan

# Test 20: SwiftLint field validation
query IIII
SELECT ref_file, ref_line, error_code, severity
FROM parse_duck_hunt_log('[{"file":"/src/Test.swift","rule_id":"force_cast","severity":"error","reason":"Force casts should be avoided","line":10,"column":5}]', 'swiftlint_json');
----
/src/Test.swift	10	force_cast	error

# Test 21: PHPStan field validation
query IIII
SELECT ref_file, ref_line, status, category
FROM parse_duck_hunt_log('{"files":{"/src/Test.php":{"messages":[{"message":"Test error","line":25,"ignorable":false}]}}}', 'phpstan_json');
----
/src/Test.php	25	ERROR	static_analysis

# Test 22: SwiftLint event type validation
query I
SELECT DISTINCT event_type FROM parse_duck_hunt_log('[{"file":"test.swift","rule_id":"test_rule","severity":"warning","reason":"Test","line":1,"column":1}]', 'swiftlint_json');
----
lint_issue

# Test 23: PHPStan event type validation
query I
SELECT DISTINCT event_type FROM parse_duck_hunt_log('{"files":{"test.php":{"messages":[{"message":"Test","line":1,"ignorable":false}]}}}', 'phpstan_json');
----
lint_issue

# Test 24: SwiftLint suggestion field (type)
query I
SELECT suggestion FROM parse_duck_hunt_log('[{"file":"test.swift","rule_id":"test_rule","type":"Force Cast","severity":"error","reason":"Test","line":1,"column":1}]', 'swiftlint_json');
----
Force Cast

# Test 25: PHPStan ignorable status mapping
query II
SELECT status, severity FROM parse_duck_hunt_log('{"files":{"test.php":{"messages":[{"message":"Ignorable issue","line":1,"ignorable":true},{"message":"Critical issue","line":2,"ignorable":false}]}}}', 'phpstan_json')
ORDER BY event_id;
----
WARNING	warning
ERROR	error

# Test 26: ShellCheck JSON format parsing
statement ok
CREATE TABLE shellcheck_results AS 
SELECT * FROM read_duck_hunt_log('workspace/shellcheck_sample.json', 'shellcheck_json');

# Verify ShellCheck parsing results
query IIII
SELECT COUNT(*), tool_name,
       COUNT(CASE WHEN status = 'ERROR' THEN 1 END) as errors,
       COUNT(CASE WHEN status = 'WARNING' THEN 1 END) as warnings
FROM shellcheck_results
GROUP BY tool_name;
----
5	shellcheck	2	2

# Test 27: ShellCheck auto-detection
query I
SELECT DISTINCT tool_name FROM parse_duck_hunt_log('[{"file":"test.sh","line":1,"column":1,"level":"error","code":"SC2086","message":"Test message"}]', 'auto');
----
shellcheck

# Test 28: ShellCheck field validation
query IIII
SELECT ref_file, ref_line, error_code, severity
FROM parse_duck_hunt_log('[{"file":"/src/script.sh","line":10,"column":5,"level":"warning","code":"SC2034","message":"Variable unused"}]', 'shellcheck_json');
----
/src/script.sh	10	SC2034	warning

# Test 29: ShellCheck severity mapping
query II
SELECT severity, status FROM parse_duck_hunt_log('[{"file":"test.sh","line":1,"column":1,"level":"error","code":"SC1","message":"Error"},{"file":"test.sh","line":2,"column":1,"level":"warning","code":"SC2","message":"Warning"},{"file":"test.sh","line":3,"column":1,"level":"info","code":"SC3","message":"Info"},{"file":"test.sh","line":4,"column":1,"level":"style","code":"SC4","message":"Style"}]', 'shellcheck_json')
ORDER BY event_id;
----
error	ERROR
warning	WARNING
info	INFO
style	WARNING

# Test 30: ShellCheck event type and category validation
query II
SELECT DISTINCT event_type, category FROM parse_duck_hunt_log('[{"file":"test.sh","line":1,"column":1,"level":"error","code":"SC2086","message":"Test"}]', 'shellcheck_json');
----
lint_issue	shell_script

# Test 31: ShellCheck fix suggestion detection
query I
SELECT suggestion FROM parse_duck_hunt_log('[{"file":"test.sh","line":1,"column":1,"level":"error","code":"SC2086","message":"Test","fix":{"replacements":[{"line":1,"column":1,"replacement":"\"$var\""}]}}]', 'shellcheck_json');
----
Fix available

# Test 32: stylelint JSON format parsing
statement ok
CREATE TABLE stylelint_results AS 
SELECT * FROM read_duck_hunt_log('workspace/stylelint_sample.json', 'stylelint_json');

# Verify stylelint parsing results
query IIII
SELECT COUNT(*), tool_name,
       COUNT(CASE WHEN status = 'ERROR' THEN 1 END) as errors,
       COUNT(CASE WHEN status = 'WARNING' THEN 1 END) as warnings
FROM stylelint_results
GROUP BY tool_name;
----
5	stylelint	3	2

# Test 33: stylelint auto-detection
query I
SELECT DISTINCT tool_name FROM parse_duck_hunt_log('[{"source":"test.css","warnings":[{"line":1,"column":1,"rule":"color-no-invalid-hex","severity":"error","text":"Invalid hex color"}]}]', 'auto');
----
stylelint

# Test 34: stylelint field validation
query IIII
SELECT ref_file, ref_line, error_code, severity
FROM parse_duck_hunt_log('[{"source":"/styles/main.css","warnings":[{"line":10,"column":5,"rule":"color-no-invalid-hex","severity":"error","text":"Invalid hex color"}]}]', 'stylelint_json');
----
/styles/main.css	10	color-no-invalid-hex	error

# Test 35: stylelint severity mapping
query II
SELECT severity, status FROM parse_duck_hunt_log('[{"source":"test.css","warnings":[{"line":1,"column":1,"rule":"rule1","severity":"error","text":"Error"},{"line":2,"column":1,"rule":"rule2","severity":"warning","text":"Warning"}]}]', 'stylelint_json')
ORDER BY event_id;
----
error	ERROR
warning	WARNING

# Test 36: stylelint event type and category validation
query II
SELECT DISTINCT event_type, category FROM parse_duck_hunt_log('[{"source":"test.css","warnings":[{"line":1,"column":1,"rule":"color-no-invalid-hex","severity":"error","text":"Invalid hex color"}]}]', 'stylelint_json');
----
lint_issue	css_style

# Test 37: stylelint with no warnings
query I
SELECT COUNT(*) FROM parse_duck_hunt_log('[{"source":"clean.css","warnings":[]}]', 'stylelint_json');
----
0

# Test 38: Clippy JSON format parsing
statement ok
CREATE TABLE clippy_results AS 
SELECT * FROM read_duck_hunt_log('workspace/clippy_sample.json', 'clippy_json');

# Verify Clippy parsing results
query II
SELECT COUNT(*), tool_name
FROM clippy_results
GROUP BY tool_name;
----
4	clippy

# Test 39: Clippy auto-detection
query I
SELECT DISTINCT tool_name FROM parse_duck_hunt_log('{"message":{"message":"test warning","spans":[{"file_name":"test.rs","line_start":1,"column_start":1,"is_primary":true}],"level":"warn"}}', 'auto');
----
clippy

# Test 40: Clippy field validation
query IIII
SELECT ref_file, ref_line, error_code, severity
FROM parse_duck_hunt_log('{"message":{"message":"test warning","code":{"code":"test_lint"},"spans":[{"file_name":"src/test.rs","line_start":10,"column_start":5,"is_primary":true}],"level":"warn"}}', 'clippy_json');
----
src/test.rs	10	test_lint	warn

# Test 41: Clippy severity mapping
query II
SELECT severity, status FROM parse_duck_hunt_log('{"message":{"message":"test error","level":"error","spans":[{"file_name":"test.rs","line_start":1,"column_start":1,"is_primary":true}]}}
{"message":{"message":"test warning","level":"warn","spans":[{"file_name":"test.rs","line_start":2,"column_start":1,"is_primary":true}]}}', 'clippy_json')
ORDER BY event_id;
----
error	ERROR
warn	WARNING

# Test 42: Clippy event type and category validation
query II
SELECT DISTINCT event_type, category FROM parse_duck_hunt_log('{"message":{"message":"test warning","spans":[{"file_name":"test.rs","line_start":1,"column_start":1,"is_primary":true}],"level":"warn"}}', 'clippy_json');
----
lint_issue	code_quality

# Test 43: Clippy suggestion extraction
query I
SELECT suggestion FROM parse_duck_hunt_log('{"message":{"message":"test warning","spans":[{"file_name":"test.rs","line_start":1,"column_start":1,"is_primary":true,"suggested_replacement":"fixed_code"}],"level":"warn"}}', 'clippy_json');
----
fixed_code

# Test 44: markdownlint JSON format parsing
statement ok
CREATE TABLE markdownlint_results AS 
SELECT * FROM read_duck_hunt_log('workspace/markdownlint_sample.json', 'markdownlint_json');

# Verify markdownlint parsing results
query II
SELECT COUNT(*), tool_name
FROM markdownlint_results
GROUP BY tool_name;
----
5	markdownlint

# Test 45: markdownlint auto-detection
query I
SELECT DISTINCT tool_name FROM parse_duck_hunt_log('[{"fileName":"test.md","lineNumber":1,"ruleNames":["MD041"],"ruleDescription":"First line heading issue"}]', 'auto');
----
markdownlint

# Test 46: markdownlint field validation
query IIII
SELECT ref_file, ref_line, error_code, category
FROM parse_duck_hunt_log('[{"fileName":"docs/README.md","lineNumber":5,"ruleNames":["MD032","blanks-around-lists"],"ruleDescription":"Lists should be surrounded by blank lines"}]', 'markdownlint_json');
----
docs/README.md	5	MD032	documentation

# Test 47: markdownlint event type validation
query I
SELECT DISTINCT event_type FROM parse_duck_hunt_log('[{"fileName":"test.md","lineNumber":1,"ruleNames":["MD041"],"ruleDescription":"Test"}]', 'markdownlint_json');
----
lint_issue

# Test 48: markdownlint suggestion extraction from errorDetail
query I
SELECT suggestion FROM parse_duck_hunt_log('[{"fileName":"test.md","lineNumber":1,"ruleNames":["MD013"],"ruleDescription":"Line length","errorDetail":"Expected: 80; Actual: 95"}]', 'markdownlint_json');
----
Expected: 80; Actual: 95

# Test 49: yamllint JSON format parsing
statement ok
CREATE TABLE yamllint_results AS 
SELECT * FROM read_duck_hunt_log('workspace/yamllint_sample.json', 'yamllint_json');

# Verify yamllint parsing results
query III
SELECT COUNT(*), tool_name, COUNT(CASE WHEN status = 'ERROR' THEN 1 END) as errors
FROM yamllint_results
GROUP BY tool_name;
----
5	yamllint	3

# Test 50: yamllint auto-detection
query I
SELECT DISTINCT tool_name FROM parse_duck_hunt_log('[{"file":"test.yml","line":1,"column":1,"level":"error","rule":"indentation","message":"wrong indentation"}]', 'auto');
----
yamllint

# Test 51: yamllint field validation
query IIII
SELECT ref_file, ref_line, error_code, category
FROM parse_duck_hunt_log('[{"file":"config.yaml","line":5,"column":10,"level":"error","rule":"line_length","message":"line too long"}]', 'yamllint_json');
----
config.yaml	5	line_length	configuration

# Test 52: yamllint severity mapping
query II
SELECT severity, status FROM parse_duck_hunt_log('[{"file":"test.yml","line":1,"column":1,"level":"error","rule":"test","message":"Error"},{"file":"test.yml","line":2,"column":1,"level":"warning","rule":"test2","message":"Warning"}]', 'yamllint_json')
ORDER BY event_id;
----
error	ERROR
warning	WARNING

# Test 53: Bandit JSON format parsing
statement ok
CREATE TABLE bandit_results AS 
SELECT * FROM read_duck_hunt_log('workspace/bandit_sample.json', 'bandit_json');

# Verify Bandit parsing results
query IIII
SELECT COUNT(*), tool_name,
       COUNT(CASE WHEN status = 'ERROR' THEN 1 END) as errors,
       COUNT(CASE WHEN status = 'WARNING' THEN 1 END) as warnings
FROM bandit_results
GROUP BY tool_name;
----
4	bandit	1	1

# Test 54: Bandit auto-detection
query I
SELECT DISTINCT tool_name FROM parse_duck_hunt_log('{"results":[{"test_id":"B101","issue_severity":"HIGH","issue_confidence":"HIGH","filename":"test.py","line_number":1,"issue_text":"Test security issue"}]}', 'auto');
----
bandit

# Test 55: Bandit field validation
query IIII
SELECT ref_file, ref_line, error_code, severity
FROM parse_duck_hunt_log('{"results":[{"filename":"src/auth.py","line_number":45,"test_id":"B608","issue_severity":"HIGH","issue_confidence":"HIGH","issue_text":"SQL injection vulnerability"}]}', 'bandit_json');
----
src/auth.py	45	B608	HIGH

# Test 56: Bandit severity mapping
query II
SELECT severity, status FROM parse_duck_hunt_log('{"results":[{"filename":"test.py","line_number":1,"test_id":"B101","issue_severity":"HIGH","issue_text":"High severity"},{"filename":"test.py","line_number":2,"test_id":"B102","issue_severity":"MEDIUM","issue_text":"Medium severity"},{"filename":"test.py","line_number":3,"test_id":"B103","issue_severity":"LOW","issue_text":"Low severity"}]}', 'bandit_json')
ORDER BY event_id;
----
HIGH	ERROR
MEDIUM	WARNING
LOW	INFO

# Test 57: Bandit event type and category validation
query II
SELECT DISTINCT event_type, category FROM parse_duck_hunt_log('{"results":[{"filename":"test.py","line_number":1,"test_id":"B101","issue_severity":"HIGH","issue_text":"Security issue"}]}', 'bandit_json');
----
security_finding	security

# Test 58: Bandit CWE suggestion extraction
query I
SELECT suggestion FROM parse_duck_hunt_log('{"results":[{"filename":"test.py","line_number":1,"test_id":"B608","issue_severity":"HIGH","issue_text":"SQL injection","issue_cwe":{"id":89,"link":"https://cwe.mitre.org/data/definitions/89.html"}}]}', 'bandit_json');
----
CWE-89: https://cwe.mitre.org/data/definitions/89.html

# Test 59: Bandit function name extraction
query I
SELECT function_name FROM parse_duck_hunt_log('{"results":[{"filename":"test.py","line_number":1,"test_id":"B101","test_name":"hardcoded_password_funcarg","issue_severity":"HIGH","issue_text":"Hardcoded password"}]}', 'bandit_json');
----
hardcoded_password_funcarg

# Test 60: SpotBugs JSON format parsing
statement ok
CREATE TABLE spotbugs_results AS 
SELECT * FROM read_duck_hunt_log('workspace/spotbugs_sample.json', 'spotbugs_json');

# Verify SpotBugs parsing results
query IIIII
SELECT COUNT(*), tool_name,
       COUNT(CASE WHEN status = 'ERROR' THEN 1 END) as errors,
       COUNT(CASE WHEN status = 'WARNING' THEN 1 END) as warnings,
       COUNT(CASE WHEN status = 'INFO' THEN 1 END) as info
FROM spotbugs_results
GROUP BY tool_name;
----
4	spotbugs	1	2	1

# Test 61: SpotBugs auto-detection
query I
SELECT DISTINCT tool_name FROM parse_duck_hunt_log('{"BugCollection":{"BugInstance":[{"type":"NP_NULL_ON_SOME_PATH","priority":"2","category":"CORRECTNESS","ShortMessage":"Null pointer dereference"}]}}', 'auto');
----
spotbugs

# Test 62: SpotBugs field validation
query IIII
SELECT ref_file, ref_line, error_code, category
FROM parse_duck_hunt_log('{"BugCollection":{"BugInstance":[{"type":"SQL_NONCONSTANT_STRING_PASSED_TO_EXECUTE","priority":"1","category":"SECURITY","ShortMessage":"SQL injection","SourceLine":{"sourcepath":"com/example/Database.java","start":"45","primary":true}}]}}', 'spotbugs_json');
----
com/example/Database.java	45	SQL_NONCONSTANT_STRING_PASSED_TO_EXECUTE	security

# Test 63: SpotBugs priority mapping
query II
SELECT severity, status FROM parse_duck_hunt_log('{"BugCollection":{"BugInstance":[{"type":"HIGH_PRIORITY","priority":"1","category":"SECURITY","ShortMessage":"High"},{"type":"MED_PRIORITY","priority":"2","category":"CORRECTNESS","ShortMessage":"Medium"},{"type":"LOW_PRIORITY","priority":"3","category":"BAD_PRACTICE","ShortMessage":"Low"}]}}', 'spotbugs_json')
ORDER BY event_id;
----
1	ERROR
2	WARNING
3	INFO

# Test 64: SpotBugs category mapping to event types
query II
SELECT category, event_type FROM parse_duck_hunt_log('{"BugCollection":{"BugInstance":[{"type":"SEC_BUG","priority":"1","category":"SECURITY","ShortMessage":"Security issue"},{"type":"PERF_BUG","priority":"2","category":"PERFORMANCE","ShortMessage":"Performance issue"},{"type":"CORRECT_BUG","priority":"2","category":"CORRECTNESS","ShortMessage":"Correctness issue"},{"type":"PRACTICE_BUG","priority":"3","category":"BAD_PRACTICE","ShortMessage":"Bad practice"}]}}', 'spotbugs_json')
ORDER BY event_id;
----
security	security_finding
performance	performance_issue
correctness	lint_issue
code_quality	lint_issue

# Test 65: SpotBugs function name extraction
query I
SELECT function_name FROM parse_duck_hunt_log('{"BugCollection":{"BugInstance":[{"type":"NP_NULL","priority":"2","category":"CORRECTNESS","ShortMessage":"Null pointer","Method":{"classname":"com.example.Service","name":"processData","primary":true}}]}}', 'spotbugs_json');
----
com.example.Service.processData

# Test 66: SpotBugs suggestion extraction from LongMessage
query I
SELECT suggestion FROM parse_duck_hunt_log('{"BugCollection":{"BugInstance":[{"type":"NP_NULL","priority":"2","category":"CORRECTNESS","ShortMessage":"Null pointer","LongMessage":"Possible null pointer dereference of user in com.example.Service.processData(User)"}]}}', 'spotbugs_json');
----
Possible null pointer dereference of user in com.example.Service.processData(User)

# Test 67: ktlint JSON format parsing
statement ok
CREATE TABLE ktlint_results AS 
SELECT * FROM read_duck_hunt_log('workspace/ktlint_sample.json', 'ktlint_json');

# Verify ktlint parsing results
query IIII
SELECT COUNT(*), tool_name,
       COUNT(CASE WHEN status = 'ERROR' THEN 1 END) as errors,
       COUNT(CASE WHEN status = 'WARNING' THEN 1 END) as warnings
FROM ktlint_results
GROUP BY tool_name;
----
9	ktlint	2	7

# Test 68: ktlint auto-detection
query I
SELECT DISTINCT tool_name FROM parse_duck_hunt_log('[{"file":"Test.kt","errors":[{"line":1,"column":1,"message":"Missing newline","rule":"final-newline"}]}]', 'auto');
----
ktlint

# Test 69: ktlint field validation
query IIIII
SELECT ref_file, ref_line, ref_column, error_code, category
FROM parse_duck_hunt_log('[{"file":"src/main/kotlin/Example.kt","errors":[{"line":15,"column":25,"message":"Unnecessary semicolon","rule":"no-semi"}]}]', 'ktlint_json');
----
src/main/kotlin/Example.kt	15	25	no-semi	code_style

# Test 70: ktlint rule-based severity mapping
query II
SELECT error_code, status FROM parse_duck_hunt_log('[{"file":"Test.kt","errors":[{"line":1,"column":1,"message":"Missing newline at end of file","rule":"final-newline"},{"line":2,"column":1,"message":"Line too long","rule":"max-line-length"},{"line":3,"column":1,"message":"Wrong indentation","rule":"indent"}]}]', 'ktlint_json')
ORDER BY event_id;
----
final-newline	ERROR
max-line-length	WARNING
indent	ERROR

# Test 71: ktlint event type validation
query I
SELECT DISTINCT event_type FROM parse_duck_hunt_log('[{"file":"Test.kt","errors":[{"line":1,"column":1,"message":"Style issue","rule":"style-rule"}]}]', 'ktlint_json');
----
lint_issue

# Test 72: ktlint category validation
query I
SELECT DISTINCT category FROM parse_duck_hunt_log('[{"file":"Test.kt","errors":[{"line":1,"column":1,"message":"Style issue","rule":"style-rule"}]}]', 'ktlint_json');
----
code_style

# Test 73: ktlint multi-file parsing
query II
SELECT ref_file, COUNT(*) as error_count FROM parse_duck_hunt_log('[{"file":"File1.kt","errors":[{"line":1,"column":1,"message":"Error 1","rule":"rule1"}]},{"file":"File2.kt","errors":[{"line":2,"column":2,"message":"Error 2","rule":"rule2"},{"line":3,"column":3,"message":"Error 3","rule":"rule3"}]}]', 'ktlint_json')
GROUP BY ref_file ORDER BY ref_file;
----
File1.kt	1
File2.kt	2

# Test 74: hadolint JSON format parsing
statement ok
CREATE TABLE hadolint_results AS 
SELECT * FROM read_duck_hunt_log('workspace/hadolint_sample.json', 'hadolint_json');

# Verify hadolint parsing results
query IIIII
SELECT COUNT(*), tool_name,
       COUNT(CASE WHEN status = 'ERROR' THEN 1 END) as errors,
       COUNT(CASE WHEN status = 'WARNING' THEN 1 END) as warnings,
       COUNT(CASE WHEN status = 'INFO' THEN 1 END) as info
FROM hadolint_results
GROUP BY tool_name;
----
10	hadolint	4	4	2

# Test 75: hadolint auto-detection
query I
SELECT DISTINCT tool_name FROM parse_duck_hunt_log('[{"file":"Dockerfile","line":1,"column":1,"level":"error","code":"DL3006","message":"Always tag the version"}]', 'auto');
----
hadolint

# Test 76: hadolint field validation
query IIIII
SELECT ref_file, ref_line, ref_column, error_code, category
FROM parse_duck_hunt_log('[{"file":"Dockerfile","line":5,"column":1,"level":"warning","code":"DL3008","message":"Pin versions in apt get install"}]', 'hadolint_json');
----
Dockerfile	5	1	DL3008	dockerfile

# Test 77: hadolint level mapping
query II
SELECT severity, status FROM parse_duck_hunt_log('[{"file":"Dockerfile","line":1,"column":1,"level":"error","code":"DL1","message":"Error"},{"file":"Dockerfile","line":2,"column":1,"level":"warning","code":"DL2","message":"Warning"},{"file":"Dockerfile","line":3,"column":1,"level":"info","code":"DL3","message":"Info"},{"file":"Dockerfile","line":4,"column":1,"level":"style","code":"DL4","message":"Style"}]', 'hadolint_json')
ORDER BY event_id;
----
error	ERROR
warning	WARNING
info	INFO
style	WARNING

# Test 78: hadolint event type validation
query I
SELECT DISTINCT event_type FROM parse_duck_hunt_log('[{"file":"Dockerfile","line":1,"column":1,"level":"error","code":"DL3006","message":"Docker issue"}]', 'hadolint_json');
----
lint_issue

# Test 79: hadolint category validation
query I
SELECT DISTINCT category FROM parse_duck_hunt_log('[{"file":"Dockerfile","line":1,"column":1,"level":"error","code":"DL3006","message":"Docker issue"}]', 'hadolint_json');
----
dockerfile

# Test 80: hadolint multi-file Docker project
query II
SELECT ref_file, COUNT(*) as issue_count FROM parse_duck_hunt_log('[{"file":"Dockerfile","line":1,"column":1,"level":"error","code":"DL3006","message":"Issue 1"},{"file":"Dockerfile.prod","line":2,"column":1,"level":"warning","code":"DL3008","message":"Issue 2"},{"file":"docker/app/Dockerfile","line":3,"column":1,"level":"info","code":"DL3009","message":"Issue 3"}]', 'hadolint_json')
GROUP BY ref_file ORDER BY ref_file;
----
Dockerfile	1
Dockerfile.prod	1
docker/app/Dockerfile	1

# Test 81: lintr JSON format parsing
statement ok
CREATE TABLE lintr_results AS 
SELECT * FROM read_duck_hunt_log('workspace/lintr_sample.json', 'lintr_json');

# Verify lintr parsing results
query IIII
SELECT COUNT(*), tool_name,
       COUNT(CASE WHEN status = 'ERROR' THEN 1 END) as errors,
       COUNT(CASE WHEN status = 'WARNING' THEN 1 END) as warnings
FROM lintr_results
GROUP BY tool_name;
----
10	lintr	2	8

# Test 82: lintr auto-detection
query I
SELECT DISTINCT tool_name FROM parse_duck_hunt_log('[{"filename":"test.R","line_number":1,"column_number":1,"type":"style","message":"Use snake_case","linter":"object_name_linter"}]', 'auto');
----
lintr

# Test 83: lintr field validation
query IIIII
SELECT ref_file, ref_line, ref_column, error_code, category
FROM parse_duck_hunt_log('[{"filename":"analysis/script.R","line_number":15,"column_number":8,"type":"warning","message":"Line too long","linter":"line_length_linter"}]', 'lintr_json');
----
analysis/script.R	15	8	line_length_linter	r_code_style

# Test 84: lintr type mapping
query II
SELECT severity, status FROM parse_duck_hunt_log('[{"filename":"test.R","line_number":1,"column_number":1,"type":"error","message":"Error","linter":"test1"},{"filename":"test.R","line_number":2,"column_number":1,"type":"warning","message":"Warning","linter":"test2"},{"filename":"test.R","line_number":3,"column_number":1,"type":"style","message":"Style","linter":"test3"}]', 'lintr_json')
ORDER BY event_id;
----
error	ERROR
warning	WARNING
style	WARNING

# Test 85: lintr event type validation
query I
SELECT DISTINCT event_type FROM parse_duck_hunt_log('[{"filename":"test.R","line_number":1,"column_number":1,"type":"style","message":"R style issue","linter":"style_linter"}]', 'lintr_json');
----
lint_issue

# Test 86: lintr category validation
query I
SELECT DISTINCT category FROM parse_duck_hunt_log('[{"filename":"test.R","line_number":1,"column_number":1,"type":"style","message":"R style issue","linter":"style_linter"}]', 'lintr_json');
----
r_code_style

# Test 87: lintr code suggestion extraction
query I
SELECT suggestion FROM parse_duck_hunt_log('[{"filename":"test.R","line_number":1,"column_number":1,"type":"style","message":"Use snake_case","linter":"object_name_linter","line":"calculateMean <- function(x) {"}]', 'lintr_json');
----
Code: calculateMean <- function(x) {

# Test 88: lintr multi-file R project
query II
SELECT ref_file, COUNT(*) as issue_count FROM parse_duck_hunt_log('[{"filename":"analysis/data.R","line_number":1,"column_number":1,"type":"style","message":"Issue 1","linter":"linter1"},{"filename":"models/regression.R","line_number":2,"column_number":2,"type":"warning","message":"Issue 2","linter":"linter2"},{"filename":"utils/helpers.R","line_number":3,"column_number":3,"type":"error","message":"Issue 3","linter":"linter3"}]', 'lintr_json')
GROUP BY ref_file ORDER BY ref_file;
----
analysis/data.R	1
models/regression.R	1
utils/helpers.R	1

# Test 89: sqlfluff JSON format parsing
statement ok
CREATE TABLE sqlfluff_results AS 
SELECT * FROM read_duck_hunt_log('workspace/sqlfluff_sample.json', 'sqlfluff_json');

# Verify sqlfluff parsing results
query III
SELECT COUNT(*), tool_name, COUNT(CASE WHEN status = 'WARNING' THEN 1 END) as warnings
FROM sqlfluff_results
GROUP BY tool_name;
----
13	sqlfluff	13

# Test 90: sqlfluff auto-detection
query I
SELECT DISTINCT tool_name FROM parse_duck_hunt_log('[{"filepath":"test.sql","violations":[{"line_no":1,"line_pos":1,"code":"L003","description":"Expected indentation","rule":"indentation"}]}]', 'auto');
----
sqlfluff

# Test 91: sqlfluff field validation
query IIIII
SELECT ref_file, ref_line, ref_column, error_code, category
FROM parse_duck_hunt_log('[{"filepath":"queries/analytics.sql","violations":[{"line_no":10,"line_pos":5,"code":"L010","description":"Keywords must be consistently upper case","rule":"capitalisation.keywords"}]}]', 'sqlfluff_json');
----
queries/analytics.sql	10	5	L010	sql_style

# Test 92: sqlfluff violation parsing
query II
SELECT error_code, function_name FROM parse_duck_hunt_log('[{"filepath":"test.sql","violations":[{"line_no":1,"line_pos":1,"code":"L003","description":"Indentation issue","rule":"indentation"}]}]', 'sqlfluff_json');
----
L003	indentation

# Test 93: sqlfluff event type validation
query I
SELECT DISTINCT event_type FROM parse_duck_hunt_log('[{"filepath":"test.sql","violations":[{"line_no":1,"line_pos":1,"code":"L003","description":"SQL style issue","rule":"indentation"}]}]', 'sqlfluff_json');
----
lint_issue

# Test 94: sqlfluff category validation
query I
SELECT DISTINCT category FROM parse_duck_hunt_log('[{"filepath":"test.sql","violations":[{"line_no":1,"line_pos":1,"code":"L003","description":"SQL style issue","rule":"indentation"}]}]', 'sqlfluff_json');
----
sql_style

# Test 95: sqlfluff suggestion extraction
query I
SELECT suggestion FROM parse_duck_hunt_log('[{"filepath":"test.sql","violations":[{"line_no":1,"line_pos":1,"code":"L003","description":"Indentation issue","rule":"indentation"}]}]', 'sqlfluff_json');
----
Rule: indentation

# Test 96: sqlfluff multi-file SQL project
query II
SELECT ref_file, COUNT(*) as violation_count FROM parse_duck_hunt_log('[{"filepath":"queries/users.sql","violations":[{"line_no":1,"line_pos":1,"code":"L001","description":"Issue 1","rule":"rule1"}]},{"filepath":"migrations/schema.sql","violations":[{"line_no":2,"line_pos":2,"code":"L002","description":"Issue 2","rule":"rule2"},{"line_no":3,"line_pos":3,"code":"L003","description":"Issue 3","rule":"rule3"}]}]', 'sqlfluff_json')
GROUP BY ref_file ORDER BY ref_file;
----
migrations/schema.sql	2
queries/users.sql	1

# Test 97: sqlfluff with no violations
query I
SELECT COUNT(*) FROM parse_duck_hunt_log('[{"filepath":"clean.sql","violations":[]}]', 'sqlfluff_json');
----
0

# Test 98: tflint JSON format parsing
statement ok
CREATE TABLE tflint_results AS 
SELECT * FROM read_duck_hunt_log('workspace/tflint_sample.json', 'tflint_json');

# Verify tflint parsing results
query IIIII
SELECT COUNT(*), tool_name,
       COUNT(CASE WHEN status = 'ERROR' THEN 1 END) as errors,
       COUNT(CASE WHEN status = 'WARNING' THEN 1 END) as warnings,
       COUNT(CASE WHEN status = 'INFO' THEN 1 END) as info
FROM tflint_results
GROUP BY tool_name;
----
10	tflint	3	5	2

# Test 99: tflint auto-detection
query I
SELECT DISTINCT tool_name FROM parse_duck_hunt_log('{"issues":[{"rule":{"name":"terraform_deprecated_interpolation","severity":"warning"},"message":"Test issue","range":{"filename":"main.tf","start":{"line":1,"column":1}}}],"errors":[]}', 'auto');
----
tflint

# Test 100: tflint field validation
query IIIII
SELECT ref_file, ref_line, ref_column, error_code, category
FROM parse_duck_hunt_log('{"issues":[{"rule":{"name":"aws_instance_invalid_type","severity":"error"},"message":"Invalid instance type","range":{"filename":"main.tf","start":{"line":10,"column":5}}}]}', 'tflint_json');
----
main.tf	10	5	aws_instance_invalid_type	infrastructure

# Test 101: tflint severity mapping
query II
SELECT severity, status FROM parse_duck_hunt_log('{"issues":[{"rule":{"name":"test_error","severity":"error"},"message":"Error issue","range":{"filename":"test.tf","start":{"line":1,"column":1}}},{"rule":{"name":"test_warning","severity":"warning"},"message":"Warning issue","range":{"filename":"test.tf","start":{"line":2,"column":1}}},{"rule":{"name":"test_notice","severity":"notice"},"message":"Notice issue","range":{"filename":"test.tf","start":{"line":3,"column":1}}}]}', 'tflint_json')
ORDER BY event_id;
----
error	ERROR
warning	WARNING
notice	INFO

# Test 102: tflint event type validation
query I
SELECT DISTINCT event_type FROM parse_duck_hunt_log('{"issues":[{"rule":{"name":"terraform_issue","severity":"warning"},"message":"Terraform issue","range":{"filename":"main.tf","start":{"line":1,"column":1}}}]}', 'tflint_json');
----
lint_issue

# Test 103: tflint category validation
query I
SELECT DISTINCT category FROM parse_duck_hunt_log('{"issues":[{"rule":{"name":"terraform_issue","severity":"warning"},"message":"Terraform issue","range":{"filename":"main.tf","start":{"line":1,"column":1}}}]}', 'tflint_json');
----
infrastructure

# Test 104: tflint suggestion extraction
query I
SELECT suggestion FROM parse_duck_hunt_log('{"issues":[{"rule":{"name":"terraform_deprecated_interpolation","severity":"warning"},"message":"Use new syntax","range":{"filename":"main.tf","start":{"line":1,"column":1}}}]}', 'tflint_json');
----
Rule: terraform_deprecated_interpolation

# Test 105: tflint multi-file Terraform project
query II
SELECT ref_file, COUNT(*) as issue_count FROM parse_duck_hunt_log('{"issues":[{"rule":{"name":"rule1","severity":"error"},"message":"Issue 1","range":{"filename":"main.tf","start":{"line":1,"column":1}}},{"rule":{"name":"rule2","severity":"warning"},"message":"Issue 2","range":{"filename":"variables.tf","start":{"line":2,"column":2}}},{"rule":{"name":"rule3","severity":"notice"},"message":"Issue 3","range":{"filename":"variables.tf","start":{"line":3,"column":3}}}]}', 'tflint_json')
GROUP BY ref_file ORDER BY ref_file;
----
main.tf	1
variables.tf	2

# Test 106: tflint with no issues
query I
SELECT COUNT(*) FROM parse_duck_hunt_log('{"issues":[],"errors":[]}', 'tflint_json');
----
0

# Test 107: kube-score JSON format parsing
statement ok
CREATE TABLE kube_score_results AS 
SELECT * FROM read_duck_hunt_log('workspace/kube_score_sample.json', 'kube_score_json');

# Verify kube-score parsing results
query IIII
SELECT COUNT(*), tool_name,
       COUNT(CASE WHEN status = 'ERROR' THEN 1 END) as errors,
       COUNT(CASE WHEN status = 'WARNING' THEN 1 END) as warnings
FROM kube_score_results
GROUP BY tool_name;
----
10	kube-score	3	7

# Test 108: kube-score auto-detection
query I
SELECT DISTINCT tool_name FROM parse_duck_hunt_log('[{"object_name":"test-app","type_meta":{"kind":"Deployment"},"file_name":"test.yaml","checks":[{"check":{"id":"container-resources","name":"Container Resources"},"grade":"WARNING","comments":[{"summary":"Resource limits not set"}]}]}]', 'auto');
----
kube-score

# Test 109: kube-score field validation
query IIIII
SELECT ref_file, ref_line, error_code, category, function_name
FROM parse_duck_hunt_log('[{"object_name":"my-app","type_meta":{"kind":"Deployment"},"file_name":"deployment.yaml","file_row":5,"checks":[{"check":{"id":"container-security-context","name":"Container Security"},"grade":"CRITICAL","comments":[{"summary":"Container runs as root"}]}]}]', 'kube_score_json');
----
deployment.yaml	5	container-security-context	kubernetes	my-app (Deployment)

# Test 110: kube-score severity mapping
query II
SELECT severity, status FROM parse_duck_hunt_log('[{"object_name":"test","type_meta":{"kind":"Pod"},"file_name":"test.yaml","checks":[{"check":{"id":"test1"},"grade":"CRITICAL","comments":[{"summary":"Critical issue"}]},{"check":{"id":"test2"},"grade":"WARNING","comments":[{"summary":"Warning issue"}]}]}]', 'kube_score_json')
ORDER BY event_id;
----
critical	ERROR
warning	WARNING

# Test 111: kube-score event type validation
query I
SELECT DISTINCT event_type FROM parse_duck_hunt_log('[{"object_name":"test","type_meta":{"kind":"Service"},"file_name":"test.yaml","checks":[{"check":{"id":"service-check"},"grade":"WARNING","comments":[{"summary":"K8s issue"}]}]}]', 'kube_score_json');
----
lint_issue

# Test 112: kube-score category validation
query I
SELECT DISTINCT category FROM parse_duck_hunt_log('[{"object_name":"test","type_meta":{"kind":"Deployment"},"file_name":"test.yaml","checks":[{"check":{"id":"k8s-check"},"grade":"WARNING","comments":[{"summary":"Kubernetes issue"}]}]}]', 'kube_score_json');
----
kubernetes

# Test 113: kube-score suggestion extraction
query I
SELECT suggestion FROM parse_duck_hunt_log('[{"object_name":"test","type_meta":{"kind":"Pod"},"file_name":"test.yaml","checks":[{"check":{"id":"test-check"},"grade":"WARNING","comments":[{"summary":"Issue summary","description":"Detailed description of the issue"}]}]}]', 'kube_score_json');
----
Detailed description of the issue

# Test 114: kube-score multi-resource Kubernetes project
query II
SELECT function_name, COUNT(*) as issue_count FROM parse_duck_hunt_log('[{"object_name":"app","type_meta":{"kind":"Deployment"},"file_name":"app.yaml","checks":[{"check":{"id":"check1"},"grade":"WARNING","comments":[{"summary":"Issue 1"}]}]},{"object_name":"svc","type_meta":{"kind":"Service"},"file_name":"service.yaml","checks":[{"check":{"id":"check2"},"grade":"CRITICAL","comments":[{"summary":"Issue 2"},{"summary":"Issue 3"}]}]}]', 'kube_score_json')
GROUP BY function_name ORDER BY function_name;
----
app (Deployment)	1
svc (Service)	2

# Test 115: kube-score with path information
query I
SELECT test_name FROM parse_duck_hunt_log('[{"object_name":"test","type_meta":{"kind":"Pod"},"file_name":"test.yaml","checks":[{"check":{"id":"test-check"},"grade":"WARNING","comments":[{"path":"spec.containers[0].resources","summary":"Resource issue"}]}]}]', 'kube_score_json');
----
spec.containers[0].resources

# Test 116: kube-score with no issues (only OK checks)
query I
SELECT COUNT(*) FROM parse_duck_hunt_log('[{"object_name":"clean-app","type_meta":{"kind":"Deployment"},"file_name":"clean.yaml","checks":[{"check":{"id":"test-check"},"grade":"OK","comments":[]}]}]', 'kube_score_json');
----
0

# Test 117: CMake build output parsing
statement ok
CREATE TABLE cmake_results AS 
SELECT * FROM read_duck_hunt_log('workspace/cmake_sample.txt', 'cmake_build');

# Verify CMake parsing results
query IIII
SELECT COUNT(*), tool_name,
       COUNT(CASE WHEN status = 'ERROR' THEN 1 END) as errors,
       COUNT(CASE WHEN status = 'WARNING' THEN 1 END) as warnings
FROM cmake_results
GROUP BY tool_name;
----
24	cmake	18	5

# Test 118: CMake auto-detection
query I
SELECT DISTINCT tool_name FROM parse_duck_hunt_log('CMake Error at CMakeLists.txt:25 (find_package):
Could not find package
gmake[1]: *** [all] Error 2
Building CXX object main.cpp.o', 'auto');
----
cmake

# Test 119: CMake compilation error parsing
query IIIII
SELECT ref_file, ref_line, ref_column, category, severity
FROM parse_duck_hunt_log('/home/user/src/main.cpp:15:10: error: iostream file not found', 'cmake_build');
----
/home/user/src/main.cpp	15	10	compilation	error

# Test 120: CMake configuration error parsing
query IIII
SELECT ref_file, ref_line, category, message LIKE '%find_package%' as has_package_error
FROM parse_duck_hunt_log('CMake Error at CMakeLists.txt:25 (find_package):
  Could not find a package configuration file provided by "Boost"', 'cmake_build');
----
CMakeLists.txt	25	configuration	true

# Test 121: CMake linker error parsing
query III
SELECT function_name, category, suggestion LIKE '%Link the library%' as has_suggestion
FROM parse_duck_hunt_log('/usr/bin/ld: database.cpp: undefined reference to `mysql_init`', 'cmake_build');
----
mysql_init	linking	true

# Test 122: CMake severity mapping
query II
SELECT category, status FROM parse_duck_hunt_log('/home/test.cpp:10:5: error: syntax error
/home/test.cpp:15:8: warning: unused variable
CMake Error at CMakeLists.txt:10:
CMake Warning at CMakeLists.txt:20:', 'cmake_build')
ORDER BY event_id;
----
compilation	ERROR
compilation	WARNING
configuration	ERROR
configuration	WARNING

# Test 122b: CMake warning variants (Deprecation Warning, Developer Warning)
query III
SELECT status, category, message LIKE '%Deprecation%' as is_deprecation FROM parse_duck_hunt_log('CMake Deprecation Warning at /home/test/CMakeLists.txt:1 (cmake_minimum_required):
  Compatibility with CMake < 3.10 will be removed
CMake Developer Warning at /home/test/CMakeLists.txt:5:
  Some developer warning message
CMake Warning at /home/test/CMakeLists.txt:10:
  Standard warning message', 'cmake_build')
ORDER BY event_id;
----
WARNING	configuration	true
WARNING	configuration	false
WARNING	configuration	false

# Test 123: CMake event type validation
query I
SELECT DISTINCT event_type FROM parse_duck_hunt_log('/home/test.cpp:10:5: error: build failed', 'cmake_build');
----
build_error

# Test 124: CMake category validation
query I
SELECT DISTINCT category FROM parse_duck_hunt_log('/home/test.cpp:10:5: error: compilation failed
/usr/bin/ld: undefined reference to test
CMake Error at CMakeLists.txt:10:
gmake[1]: *** [all] Error 2', 'cmake_build')
ORDER BY category;
----
build_failure
compilation
configuration
linking

# Test 125: CMake multi-file project errors
query II
SELECT ref_file, COUNT(*) as error_count FROM parse_duck_hunt_log('/home/main.cpp:10:5: error: syntax error
/home/utils.cpp:15:8: warning: unused variable
/home/config.cpp:20:1: error: missing semicolon', 'cmake_build')
WHERE ref_file IS NOT NULL
GROUP BY ref_file ORDER BY ref_file;
----
/home/config.cpp	1
/home/main.cpp	1
/home/utils.cpp	1

# ============================================================================
# File-based sqlfluff tests (Tests 126-131)
# ============================================================================

# Test 126: sqlfluff file-based parsing - total count
query II
SELECT COUNT(*), tool_name
FROM read_duck_hunt_log('test/samples/linting_tools/sqlfluff_output.json', 'sqlfluff_json')
GROUP BY tool_name;
----
22	sqlfluff

# Test 127: sqlfluff file-based parsing - violations by file
query II
SELECT ref_file, COUNT(*) as violation_count
FROM read_duck_hunt_log('test/samples/linting_tools/sqlfluff_output.json', 'sqlfluff_json')
GROUP BY ref_file
ORDER BY violation_count DESC, ref_file
LIMIT 5;
----
dbt/models/marts/fct_sales.sql	3
migrations/2024/001_create_users.sql	3
queries/analytics/user_engagement.sql	3
views/dashboard/monthly_summary.sql	3
dbt/models/staging/stg_customers.sql	2

# Test 128: sqlfluff file-based parsing - distinct file count
query I
SELECT COUNT(DISTINCT ref_file)
FROM read_duck_hunt_log('test/samples/linting_tools/sqlfluff_output.json', 'sqlfluff_json');
----
10

# Test 129: sqlfluff file-based parsing - rule extraction
query II
SELECT error_code, function_name
FROM read_duck_hunt_log('test/samples/linting_tools/sqlfluff_output.json', 'sqlfluff_json')
WHERE ref_file = 'queries/analytics/user_engagement.sql'
ORDER BY ref_line;
----
L003	indentation
L010	capitalisation.keywords
L014	capitalisation.identifiers

# Test 130: sqlfluff file-based parsing - all warnings status
query I
SELECT COUNT(*) = 22
FROM read_duck_hunt_log('test/samples/linting_tools/sqlfluff_output.json', 'sqlfluff_json')
WHERE status = 'WARNING';
----
true

# Test 131: sqlfluff file-based parsing - log_file tracking
query I
SELECT DISTINCT log_file
FROM read_duck_hunt_log('test/samples/linting_tools/sqlfluff_output.json', 'sqlfluff_json');
----
test/samples/linting_tools/sqlfluff_output.json

# ============================================================================
# File-based lintr tests (Tests 132-137)
# ============================================================================

# Test 132: lintr file-based parsing - total count and severity breakdown
query III
SELECT COUNT(*),
       SUM(CASE WHEN status='ERROR' THEN 1 ELSE 0 END) as errors,
       SUM(CASE WHEN status='WARNING' THEN 1 ELSE 0 END) as warnings
FROM read_duck_hunt_log('test/samples/linting_tools/lintr_output.json', 'lintr_json');
----
20	2	18

# Test 133: lintr file-based parsing - issues by file
query II
SELECT ref_file, COUNT(*) as issue_count
FROM read_duck_hunt_log('test/samples/linting_tools/lintr_output.json', 'lintr_json')
GROUP BY ref_file
ORDER BY issue_count DESC, ref_file
LIMIT 5;
----
models/regression_analysis.R	4
R/package_functions.R	3
analysis/data_processing.R	3
scripts/etl_pipeline.R	3
tests/test_models.R	3

# Test 134: lintr file-based parsing - distinct file count
query I
SELECT COUNT(DISTINCT ref_file)
FROM read_duck_hunt_log('test/samples/linting_tools/lintr_output.json', 'lintr_json');
----
7

# Test 135: lintr file-based parsing - linter extraction
query II
SELECT error_code, severity
FROM read_duck_hunt_log('test/samples/linting_tools/lintr_output.json', 'lintr_json')
WHERE ref_file = 'models/regression_analysis.R'
ORDER BY ref_line;
----
namespace_linter	error
infix_spaces_linter	style
trailing_whitespace_linter	style
sapply_linter	warning

# Test 136: lintr file-based parsing - line content as suggestion
query I
SELECT COUNT(*) > 0
FROM read_duck_hunt_log('test/samples/linting_tools/lintr_output.json', 'lintr_json')
WHERE suggestion LIKE 'Code:%';
----
true

# Test 137: lintr file-based parsing - tool_name and category
query II
SELECT DISTINCT tool_name, category
FROM read_duck_hunt_log('test/samples/linting_tools/lintr_output.json', 'lintr_json');
----
lintr	r_code_style

# ============================================================================
# File-based spotbugs tests (Tests 138-143)
# ============================================================================

# Test 138: spotbugs file-based parsing - total count and severity breakdown
query IIII
SELECT COUNT(*),
       SUM(CASE WHEN status='ERROR' THEN 1 ELSE 0 END) as errors,
       SUM(CASE WHEN status='WARNING' THEN 1 ELSE 0 END) as warnings,
       SUM(CASE WHEN status='INFO' THEN 1 ELSE 0 END) as info
FROM read_duck_hunt_log('test/samples/linting_tools/spotbugs_output.json', 'spotbugs_json');
----
15	3	8	4

# Test 139: spotbugs file-based parsing - category distribution
query II
SELECT category, COUNT(*) as cnt
FROM read_duck_hunt_log('test/samples/linting_tools/spotbugs_output.json', 'spotbugs_json')
GROUP BY category
ORDER BY cnt DESC, category;
----
correctness	5
code_quality	4
performance	3
security	3

# Test 140: spotbugs file-based parsing - distinct file count
query I
SELECT COUNT(DISTINCT ref_file)
FROM read_duck_hunt_log('test/samples/linting_tools/spotbugs_output.json', 'spotbugs_json');
----
15

# Test 141: spotbugs file-based parsing - security findings
query II
SELECT error_code, ref_file
FROM read_duck_hunt_log('test/samples/linting_tools/spotbugs_output.json', 'spotbugs_json')
WHERE category = 'security'
ORDER BY ref_line;
----
SQL_INJECTION_JDBC	com/example/dao/UserDao.java
PATH_TRAVERSAL_IN	com/example/io/FileHandler.java
XSS_SERVLET	com/example/web/UserServlet.java

# Test 142: spotbugs file-based parsing - method extraction
query II
SELECT function_name, message
FROM read_duck_hunt_log('test/samples/linting_tools/spotbugs_output.json', 'spotbugs_json')
WHERE function_name IS NOT NULL AND function_name != ''
ORDER BY function_name
LIMIT 3;
----
com.example.cache.CacheManager.processEntries	Inefficient Map iterator
com.example.controller.RequestHandler.processRequest	Unchecked/unconfirmed cast
com.example.dao.UserDao.findByUsername	SQL injection vulnerability

# Test 143: spotbugs file-based parsing - tool_name verification
query II
SELECT DISTINCT tool_name, event_type
FROM read_duck_hunt_log('test/samples/linting_tools/spotbugs_output.json', 'spotbugs_json')
WHERE category = 'security';
----
spotbugs	security_finding

# ============================================================================
# File-based ktlint tests (Tests 144-149)
# ============================================================================

# Test 144: ktlint file-based parsing - total count and severity breakdown
query III
SELECT COUNT(*),
       SUM(CASE WHEN status='ERROR' THEN 1 ELSE 0 END) as errors,
       SUM(CASE WHEN status='WARNING' THEN 1 ELSE 0 END) as warnings
FROM read_duck_hunt_log('test/samples/linting_tools/ktlint_output.json', 'ktlint_json');
----
18	4	14

# Test 145: ktlint file-based parsing - errors by file
query II
SELECT ref_file, COUNT(*) as error_count
FROM read_duck_hunt_log('test/samples/linting_tools/ktlint_output.json', 'ktlint_json')
GROUP BY ref_file
ORDER BY error_count DESC, ref_file
LIMIT 5;
----
src/main/kotlin/com/example/app/MainActivity.kt	3
src/main/kotlin/com/example/app/UserService.kt	3
src/main/kotlin/com/example/app/ui/HomeFragment.kt	3
src/test/kotlin/com/example/app/UserServiceTest.kt	3
src/main/kotlin/com/example/app/data/Repository.kt	2

# Test 146: ktlint file-based parsing - distinct file count
query I
SELECT COUNT(DISTINCT ref_file)
FROM read_duck_hunt_log('test/samples/linting_tools/ktlint_output.json', 'ktlint_json');
----
7

# Test 147: ktlint file-based parsing - rule extraction
query II
SELECT error_code, status
FROM read_duck_hunt_log('test/samples/linting_tools/ktlint_output.json', 'ktlint_json')
WHERE ref_file = 'src/main/kotlin/com/example/app/MainActivity.kt'
ORDER BY ref_line;
----
final-newline	ERROR
no-wildcard-imports	WARNING
indent	ERROR

# Test 148: ktlint file-based parsing - tool_name and category
query II
SELECT DISTINCT tool_name, category
FROM read_duck_hunt_log('test/samples/linting_tools/ktlint_output.json', 'ktlint_json');
----
ktlint	code_style

# Test 149: ktlint file-based parsing - log_file tracking
query I
SELECT DISTINCT log_file
FROM read_duck_hunt_log('test/samples/linting_tools/ktlint_output.json', 'ktlint_json');
----
test/samples/linting_tools/ktlint_output.json

# ============================================================================
# File-based cargo_test tests (Tests 150-155)
# ============================================================================

# Test 150: cargo_test file-based parsing - total count and result breakdown
query IIII
SELECT COUNT(*),
       SUM(CASE WHEN status='PASS' THEN 1 ELSE 0 END) as passed,
       SUM(CASE WHEN status='FAIL' THEN 1 ELSE 0 END) as failed,
       SUM(CASE WHEN status='SKIP' THEN 1 ELSE 0 END) as ignored
FROM read_duck_hunt_log('test/samples/test_frameworks/cargo_test_output.jsonl', 'cargo_test_json');
----
14	10	2	2

# Test 151: cargo_test file-based parsing - tests by module
query II
SELECT split_part(test_name, '::', 1) as module, COUNT(*) as test_count
FROM read_duck_hunt_log('test/samples/test_frameworks/cargo_test_output.jsonl', 'cargo_test_json')
GROUP BY module
ORDER BY test_count DESC, module;
----
db	4
api	3
auth	3
core	3
integration	1

# Test 152: cargo_test file-based parsing - failed tests count
query I
SELECT COUNT(*)
FROM read_duck_hunt_log('test/samples/test_frameworks/cargo_test_output.jsonl', 'cargo_test_json')
WHERE status = 'FAIL';
----
2

# Test 153: cargo_test file-based parsing - execution time
query I
SELECT COUNT(*) > 0
FROM read_duck_hunt_log('test/samples/test_frameworks/cargo_test_output.jsonl', 'cargo_test_json')
WHERE execution_time > 0;
----
true

# Test 154: cargo_test file-based parsing - tool_name and category
query II
SELECT DISTINCT tool_name, category
FROM read_duck_hunt_log('test/samples/test_frameworks/cargo_test_output.jsonl', 'cargo_test_json');
----
cargo_test	test

# Test 155: cargo_test file-based parsing - event_type verification
query I
SELECT DISTINCT event_type
FROM read_duck_hunt_log('test/samples/test_frameworks/cargo_test_output.jsonl', 'cargo_test_json');
----
test_result

# ============================================================================
# File-based hadolint tests (Tests 156-161)
# ============================================================================

# Test 156: hadolint file-based parsing - total count and severity breakdown
query IIII
SELECT COUNT(*),
       SUM(CASE WHEN status='ERROR' THEN 1 ELSE 0 END) as errors,
       SUM(CASE WHEN status='WARNING' THEN 1 ELSE 0 END) as warnings,
       SUM(CASE WHEN status='INFO' THEN 1 ELSE 0 END) as info
FROM read_duck_hunt_log('test/samples/linting_tools/hadolint_output.json', 'hadolint_json');
----
8	1	5	2

# Test 157: hadolint file-based parsing - rule codes
query II
SELECT error_code, severity
FROM read_duck_hunt_log('test/samples/linting_tools/hadolint_output.json', 'hadolint_json')
ORDER BY ref_line;
----
DL3006	warning
DL3008	warning
DL3009	info
DL3020	error
DL3025	warning
DL4006	warning
DL3002	warning
SC2086	info

# Test 158: hadolint file-based parsing - dockerfile reference
query I
SELECT DISTINCT ref_file
FROM read_duck_hunt_log('test/samples/linting_tools/hadolint_output.json', 'hadolint_json');
----
Dockerfile

# Test 159: hadolint file-based parsing - tool_name and category
query II
SELECT DISTINCT tool_name, category
FROM read_duck_hunt_log('test/samples/linting_tools/hadolint_output.json', 'hadolint_json');
----
hadolint	dockerfile

# Test 160: hadolint file-based parsing - shellcheck rules (SC codes)
query I
SELECT COUNT(*)
FROM read_duck_hunt_log('test/samples/linting_tools/hadolint_output.json', 'hadolint_json')
WHERE error_code LIKE 'SC%';
----
1

# Test 161: hadolint file-based parsing - log_file tracking
query I
SELECT DISTINCT log_file
FROM read_duck_hunt_log('test/samples/linting_tools/hadolint_output.json', 'hadolint_json');
----
test/samples/linting_tools/hadolint_output.json

# ============================================================================
# File-based bandit tests (Tests 162-167)
# ============================================================================

# Test 162: bandit file-based parsing - total count and severity
query III
SELECT COUNT(*),
       SUM(CASE WHEN severity = 'HIGH' THEN 1 ELSE 0 END) as high,
       SUM(CASE WHEN severity = 'MEDIUM' THEN 1 ELSE 0 END) as medium
FROM read_duck_hunt_log('test/samples/linting_tools/bandit_output.json', 'bandit_json');
----
5	3	2

# Test 163: bandit file-based parsing - security findings by file
query II
SELECT ref_file, error_code
FROM read_duck_hunt_log('test/samples/linting_tools/bandit_output.json', 'bandit_json')
ORDER BY ref_file;
----
myapp/api/auth.py	B608
myapp/config.py	B105
myapp/services/cache.py	B301
myapp/services/processor.py	B307
myapp/utils/helpers.py	B602

# Test 164: bandit file-based parsing - test_id in structured_data
query I
SELECT COUNT(*) > 0
FROM read_duck_hunt_log('test/samples/linting_tools/bandit_output.json', 'bandit_json')
WHERE structured_data LIKE '%test_id%';
----
true

# Test 165: bandit file-based parsing - tool_name and category
query II
SELECT DISTINCT tool_name, category
FROM read_duck_hunt_log('test/samples/linting_tools/bandit_output.json', 'bandit_json');
----
bandit	security

# Test 166: bandit file-based parsing - event type for security
query I
SELECT DISTINCT event_type
FROM read_duck_hunt_log('test/samples/linting_tools/bandit_output.json', 'bandit_json');
----
security_finding

# Test 167: bandit file-based parsing - log_file tracking
query I
SELECT DISTINCT log_file
FROM read_duck_hunt_log('test/samples/linting_tools/bandit_output.json', 'bandit_json');
----
test/samples/linting_tools/bandit_output.json

# Test: bandit CWE IDs should be in structured_data (Issue #25 - fixed)
query I
SELECT COUNT(*)
FROM read_duck_hunt_log('test/samples/linting_tools/bandit_output.json', 'bandit_json')
WHERE structured_data LIKE '%cwe%';
----
5

# ============================================================================
# File-based shellcheck tests (Tests 168-173)
# ============================================================================

# Test 168: shellcheck file-based parsing - total count
query II
SELECT COUNT(*), COUNT(DISTINCT ref_file)
FROM read_duck_hunt_log('test/samples/linting_tools/shellcheck_output.json', 'shellcheck_json');
----
7	2

# Test 169: shellcheck file-based parsing - issues by file
query II
SELECT ref_file, COUNT(*) as issue_count
FROM read_duck_hunt_log('test/samples/linting_tools/shellcheck_output.json', 'shellcheck_json')
GROUP BY ref_file
ORDER BY ref_file;
----
scripts/backup.sh	3
scripts/deploy.sh	4

# Test 170: shellcheck file-based parsing - severity levels
query II
SELECT severity, COUNT(*) as cnt
FROM read_duck_hunt_log('test/samples/linting_tools/shellcheck_output.json', 'shellcheck_json')
GROUP BY severity
ORDER BY severity;
----
error	2
info	1
style	1
warning	3

# Test 171: shellcheck file-based parsing - tool_name and category
query II
SELECT DISTINCT tool_name, category
FROM read_duck_hunt_log('test/samples/linting_tools/shellcheck_output.json', 'shellcheck_json');
----
shellcheck	shell_script

# Test 172: shellcheck file-based parsing - fix suggestions available
query I
SELECT COUNT(*) > 0
FROM read_duck_hunt_log('test/samples/linting_tools/shellcheck_output.json', 'shellcheck_json')
WHERE suggestion IS NOT NULL AND suggestion != '';
----
true

# Test 173: shellcheck file-based parsing - log_file tracking
query I
SELECT DISTINCT log_file
FROM read_duck_hunt_log('test/samples/linting_tools/shellcheck_output.json', 'shellcheck_json');
----
test/samples/linting_tools/shellcheck_output.json

# Test: shellcheck SC codes should be extracted (Issue #25 - fixed)
query II
SELECT error_code, severity
FROM read_duck_hunt_log('test/samples/linting_tools/shellcheck_output.json', 'shellcheck_json')
WHERE ref_file = 'scripts/deploy.sh'
ORDER BY ref_line;
----
SC2086	warning
SC2154	error
SC2034	warning
SC2103	info

# ============================================================================
# File-based rubocop tests (Tests 174-179)
# ============================================================================

# Test 174: rubocop file-based parsing - total count and severity
query III
SELECT COUNT(*),
       SUM(CASE WHEN status='ERROR' THEN 1 ELSE 0 END) as errors,
       SUM(CASE WHEN status='WARNING' THEN 1 ELSE 0 END) as warnings
FROM read_duck_hunt_log('test/samples/linting_tools/rubocop_output.json', 'rubocop_json');
----
6	1	5

# Test 175: rubocop file-based parsing - offenses by file
query II
SELECT ref_file, COUNT(*) as offense_count
FROM read_duck_hunt_log('test/samples/linting_tools/rubocop_output.json', 'rubocop_json')
GROUP BY ref_file
ORDER BY offense_count DESC, ref_file;
----
app/controllers/users_controller.rb	3
app/models/user.rb	2
app/services/auth_service.rb	1

# Test 176: rubocop file-based parsing - cop names
query II
SELECT error_code, severity
FROM read_duck_hunt_log('test/samples/linting_tools/rubocop_output.json', 'rubocop_json')
WHERE ref_file = 'app/models/user.rb'
ORDER BY ref_line;
----
Style/Documentation	convention
Lint/UselessAssignment	warning

# Test 177: rubocop file-based parsing - tool_name and category
query II
SELECT DISTINCT tool_name, category
FROM read_duck_hunt_log('test/samples/linting_tools/rubocop_output.json', 'rubocop_json');
----
rubocop	code_quality

# Test 178: rubocop file-based parsing - event_type verification
query I
SELECT DISTINCT event_type
FROM read_duck_hunt_log('test/samples/linting_tools/rubocop_output.json', 'rubocop_json');
----
lint_issue

# Test 179: rubocop file-based parsing - log_file tracking
query I
SELECT DISTINCT log_file
FROM read_duck_hunt_log('test/samples/linting_tools/rubocop_output.json', 'rubocop_json');
----
test/samples/linting_tools/rubocop_output.json

# Test: rubocop correctable info should be in suggestion (Issue #25 - fixed)
query I
SELECT COUNT(*)
FROM read_duck_hunt_log('test/samples/linting_tools/rubocop_output.json', 'rubocop_json')
WHERE suggestion LIKE '%correctable%';
----
2

# ============================================================================
# File-based stylelint tests (Tests 180-185)
# ============================================================================

# Test 180: stylelint file-based parsing - total count and severity
query III
SELECT COUNT(*),
       SUM(CASE WHEN severity = 'error' THEN 1 ELSE 0 END) as errors,
       SUM(CASE WHEN severity = 'warning' THEN 1 ELSE 0 END) as warnings
FROM read_duck_hunt_log('test/samples/linting_tools/stylelint_output.json', 'stylelint_json');
----
15	7	8

# Test 181: stylelint file-based parsing - issues by file
query II
SELECT ref_file, COUNT(*) as cnt
FROM read_duck_hunt_log('test/samples/linting_tools/stylelint_output.json', 'stylelint_json')
GROUP BY ref_file
ORDER BY ref_file;
----
src/styles/components/button.css	3
src/styles/components/card.scss	3
src/styles/layout/grid.css	2
src/styles/main.css	4
src/styles/utilities/helpers.css	3

# Test 182: stylelint file-based parsing - rule names (error_code)
query II
SELECT error_code, ref_line
FROM read_duck_hunt_log('test/samples/linting_tools/stylelint_output.json', 'stylelint_json')
WHERE ref_file = 'src/styles/main.css'
ORDER BY ref_line;
----
color-hex-length	12
declaration-block-no-duplicate-properties	25
no-descending-specificity	38
unit-no-unknown	52

# Test 183: stylelint file-based parsing - tool_name and category
query II
SELECT DISTINCT tool_name, category
FROM read_duck_hunt_log('test/samples/linting_tools/stylelint_output.json', 'stylelint_json');
----
stylelint	css_style

# Test 184: stylelint file-based parsing - event_type verification
query II
SELECT event_type, COUNT(*)
FROM read_duck_hunt_log('test/samples/linting_tools/stylelint_output.json', 'stylelint_json')
GROUP BY event_type;
----
lint_issue	15

# Test 185: stylelint file-based parsing - log_file tracking
query I
SELECT DISTINCT log_file
FROM read_duck_hunt_log('test/samples/linting_tools/stylelint_output.json', 'stylelint_json');
----
test/samples/linting_tools/stylelint_output.json

# ============================================================================
# File-based clippy tests (Tests 186-191)
# ============================================================================

# Test 186: clippy file-based parsing - total count and severity
query III
SELECT COUNT(*),
       SUM(CASE WHEN severity = 'error' THEN 1 ELSE 0 END) as errors,
       SUM(CASE WHEN severity = 'warn' THEN 1 ELSE 0 END) as warnings
FROM read_duck_hunt_log('test/samples/linting_tools/clippy_output.jsonl', 'clippy_json');
----
12	3	9

# Test 187: clippy file-based parsing - issues by file
query II
SELECT ref_file, COUNT(*) as cnt
FROM read_duck_hunt_log('test/samples/linting_tools/clippy_output.jsonl', 'clippy_json')
GROUP BY ref_file
ORDER BY ref_file;
----
src/handlers.rs	2
src/lib.rs	3
src/main.rs	2
src/parser.rs	2
src/utils.rs	3

# Test 188: clippy file-based parsing - error codes for lib.rs
query II
SELECT error_code, ref_line
FROM read_duck_hunt_log('test/samples/linting_tools/clippy_output.jsonl', 'clippy_json')
WHERE ref_file = 'src/lib.rs'
ORDER BY ref_line;
----
unused_mut	12
clippy::unwrap_used	30
clippy::iter_count	62

# Test 189: clippy file-based parsing - tool_name and category
query II
SELECT DISTINCT tool_name, category
FROM read_duck_hunt_log('test/samples/linting_tools/clippy_output.jsonl', 'clippy_json');
----
clippy	code_quality

# Test 190: clippy file-based parsing - event_type verification
query II
SELECT event_type, COUNT(*)
FROM read_duck_hunt_log('test/samples/linting_tools/clippy_output.jsonl', 'clippy_json')
GROUP BY event_type;
----
lint_issue	12

# Test 191: clippy file-based parsing - log_file tracking
query I
SELECT DISTINCT log_file
FROM read_duck_hunt_log('test/samples/linting_tools/clippy_output.jsonl', 'clippy_json');
----
test/samples/linting_tools/clippy_output.jsonl

# ============================================================================
# File-based swiftlint tests (Tests 192-197)
# ============================================================================

# Test 192: swiftlint file-based parsing - total count and severity
query III
SELECT COUNT(*),
       SUM(CASE WHEN severity = 'error' THEN 1 ELSE 0 END) as errors,
       SUM(CASE WHEN severity = 'warning' THEN 1 ELSE 0 END) as warnings
FROM read_duck_hunt_log('test/samples/linting_tools/swiftlint_output.json', 'swiftlint_json');
----
14	3	11

# Test 193: swiftlint file-based parsing - issues by suggestion type (rule type)
query II
SELECT suggestion, COUNT(*) as cnt
FROM read_duck_hunt_log('test/samples/linting_tools/swiftlint_output.json', 'swiftlint_json')
GROUP BY suggestion
ORDER BY cnt DESC, suggestion;
----
idiomatic	4
metrics	4
style	4
lint	2

# Test 194: swiftlint file-based parsing - error codes for AuthService
query II
SELECT error_code, ref_line
FROM read_duck_hunt_log('test/samples/linting_tools/swiftlint_output.json', 'swiftlint_json')
WHERE ref_file LIKE '%AuthService.swift'
ORDER BY ref_line;
----
force_try	35
unused_closure_parameter	58

# Test 195: swiftlint file-based parsing - tool_name and category
query II
SELECT DISTINCT tool_name, category
FROM read_duck_hunt_log('test/samples/linting_tools/swiftlint_output.json', 'swiftlint_json');
----
swiftlint	code_quality

# Test 196: swiftlint file-based parsing - event_type verification
query II
SELECT event_type, COUNT(*)
FROM read_duck_hunt_log('test/samples/linting_tools/swiftlint_output.json', 'swiftlint_json')
GROUP BY event_type;
----
lint_issue	14

# Test 197: swiftlint file-based parsing - log_file tracking
query I
SELECT DISTINCT log_file
FROM read_duck_hunt_log('test/samples/linting_tools/swiftlint_output.json', 'swiftlint_json');
----
test/samples/linting_tools/swiftlint_output.json

# ============================================================================
# File-based phpstan tests (Tests 198-203)
# ============================================================================

# Test 198: phpstan file-based parsing - total count and severity
query III
SELECT COUNT(*),
       SUM(CASE WHEN severity = 'error' THEN 1 ELSE 0 END) as errors,
       SUM(CASE WHEN severity = 'warning' THEN 1 ELSE 0 END) as warnings
FROM read_duck_hunt_log('test/samples/linting_tools/phpstan_output.json', 'phpstan_json');
----
15	8	7

# Test 199: phpstan file-based parsing - issues by file
query II
SELECT ref_file, COUNT(*) as cnt
FROM read_duck_hunt_log('test/samples/linting_tools/phpstan_output.json', 'phpstan_json')
GROUP BY ref_file
ORDER BY ref_file;
----
src/Controller/UserController.php	3
src/Entity/Order.php	3
src/Repository/ProductRepository.php	2
src/Service/PaymentService.php	4
src/Validator/EmailValidator.php	2
tests/Unit/UserTest.php	1

# Test 200: phpstan file-based parsing - issues with tips (suggestions)
query II
SELECT ref_file, ref_line
FROM read_duck_hunt_log('test/samples/linting_tools/phpstan_output.json', 'phpstan_json')
WHERE suggestion IS NOT NULL AND suggestion != ''
ORDER BY ref_file, ref_line;
----
src/Controller/UserController.php	25
src/Entity/Order.php	28
src/Service/PaymentService.php	15
src/Service/PaymentService.php	82
src/Validator/EmailValidator.php	35

# Test 201: phpstan file-based parsing - tool_name and category
query II
SELECT DISTINCT tool_name, category
FROM read_duck_hunt_log('test/samples/linting_tools/phpstan_output.json', 'phpstan_json');
----
phpstan	static_analysis

# Test 202: phpstan file-based parsing - event_type verification
query II
SELECT event_type, COUNT(*)
FROM read_duck_hunt_log('test/samples/linting_tools/phpstan_output.json', 'phpstan_json')
GROUP BY event_type;
----
lint_issue	15

# Test 203: phpstan file-based parsing - log_file tracking
query I
SELECT DISTINCT log_file
FROM read_duck_hunt_log('test/samples/linting_tools/phpstan_output.json', 'phpstan_json');
----
test/samples/linting_tools/phpstan_output.json

# ============================================================================
# File-based markdownlint tests (Tests 204-209)
# ============================================================================

# Test 204: markdownlint file-based parsing - total count
query I
SELECT COUNT(*)
FROM read_duck_hunt_log('test/samples/linting_tools/markdownlint_output.json', 'markdownlint_json');
----
12

# Test 205: markdownlint file-based parsing - issues by file
query II
SELECT ref_file, COUNT(*) as cnt
FROM read_duck_hunt_log('test/samples/linting_tools/markdownlint_output.json', 'markdownlint_json')
GROUP BY ref_file
ORDER BY ref_file;
----
CHANGELOG.md	1
CONTRIBUTING.md	2
README.md	3
docs/api.md	3
docs/installation.md	3

# Test 206: markdownlint file-based parsing - error codes for README
query II
SELECT error_code, ref_line
FROM read_duck_hunt_log('test/samples/linting_tools/markdownlint_output.json', 'markdownlint_json')
WHERE ref_file = 'README.md'
ORDER BY ref_line;
----
MD041	1
MD013	15
MD032	28

# Test 207: markdownlint file-based parsing - tool_name and category
query II
SELECT DISTINCT tool_name, category
FROM read_duck_hunt_log('test/samples/linting_tools/markdownlint_output.json', 'markdownlint_json');
----
markdownlint	documentation

# Test 208: markdownlint file-based parsing - event_type verification
query II
SELECT event_type, COUNT(*)
FROM read_duck_hunt_log('test/samples/linting_tools/markdownlint_output.json', 'markdownlint_json')
GROUP BY event_type;
----
lint_issue	12

# Test 209: markdownlint file-based parsing - log_file tracking
query I
SELECT DISTINCT log_file
FROM read_duck_hunt_log('test/samples/linting_tools/markdownlint_output.json', 'markdownlint_json');
----
test/samples/linting_tools/markdownlint_output.json

# ============================================================================
# File-based yamllint tests (Tests 210-215)
# ============================================================================

# Test 210: yamllint file-based parsing - total count and severity
query III
SELECT COUNT(*),
       SUM(CASE WHEN severity = 'error' THEN 1 ELSE 0 END) as errors,
       SUM(CASE WHEN severity = 'warning' THEN 1 ELSE 0 END) as warnings
FROM read_duck_hunt_log('test/samples/linting_tools/yamllint_output.json', 'yamllint_json');
----
15	4	11

# Test 211: yamllint file-based parsing - issues by file
query II
SELECT ref_file, COUNT(*) as cnt
FROM read_duck_hunt_log('test/samples/linting_tools/yamllint_output.json', 'yamllint_json')
GROUP BY ref_file
ORDER BY ref_file;
----
.github/workflows/ci.yml	3
ansible/playbook.yml	2
config/database.yml	3
docker-compose.yml	3
kubernetes/deployment.yaml	2
kubernetes/service.yaml	2

# Test 212: yamllint file-based parsing - error codes for ci.yml
query II
SELECT error_code, ref_line
FROM read_duck_hunt_log('test/samples/linting_tools/yamllint_output.json', 'yamllint_json')
WHERE ref_file = '.github/workflows/ci.yml'
ORDER BY ref_line;
----
indentation	15
line-length	28
truthy	45

# Test 213: yamllint file-based parsing - tool_name and category
query II
SELECT DISTINCT tool_name, category
FROM read_duck_hunt_log('test/samples/linting_tools/yamllint_output.json', 'yamllint_json');
----
yamllint	configuration

# Test 214: yamllint file-based parsing - event_type verification
query II
SELECT event_type, COUNT(*)
FROM read_duck_hunt_log('test/samples/linting_tools/yamllint_output.json', 'yamllint_json')
GROUP BY event_type;
----
lint_issue	15

# Test 215: yamllint file-based parsing - log_file tracking
query I
SELECT DISTINCT log_file
FROM read_duck_hunt_log('test/samples/linting_tools/yamllint_output.json', 'yamllint_json');
----
test/samples/linting_tools/yamllint_output.json

# ============================================================================
# File-based pf (BSD Packet Filter) tests (Tests 216-221)
# ============================================================================

# Test 216: pf file-based parsing - total count and severity
query III
SELECT COUNT(*),
       SUM(CASE WHEN severity = 'info' THEN 1 ELSE 0 END) as pass_count,
       SUM(CASE WHEN severity = 'warning' THEN 1 ELSE 0 END) as block_count
FROM read_duck_hunt_log('test/samples/infrastructure/pf_firewall.txt', 'pf');
----
12	5	7

# Test 217: pf file-based parsing - events by interface (category)
query II
SELECT category as interface, COUNT(*) as cnt
FROM read_duck_hunt_log('test/samples/infrastructure/pf_firewall.txt', 'pf')
GROUP BY category
ORDER BY category;
----
em0	8
em1	2
igb0	1
vtnet0	1

# Test 218: pf file-based parsing - blocked events with origin IPs
query II
SELECT origin, message
FROM read_duck_hunt_log('test/samples/infrastructure/pf_firewall.txt', 'pf')
WHERE severity = 'warning' AND category = 'em0'
ORDER BY log_line_start
LIMIT 3;
----
192.168.1.100	block in: 192.168.1.100:54321 -> 10.0.0.1:22 [S]
192.168.1.101	block in: 192.168.1.101:48762 -> 10.0.0.1:22 [S]
192.168.1.102	block in: 192.168.1.102:62341 -> 10.0.0.1:3389 [S]

# Test 219: pf file-based parsing - tool_name verification
query I
SELECT DISTINCT tool_name
FROM read_duck_hunt_log('test/samples/infrastructure/pf_firewall.txt', 'pf');
----
pf

# Test 220: pf file-based parsing - event_type verification
query II
SELECT event_type, COUNT(*)
FROM read_duck_hunt_log('test/samples/infrastructure/pf_firewall.txt', 'pf')
GROUP BY event_type;
----
debug_info	12

# Test 221: pf file-based parsing - log_file tracking
query I
SELECT DISTINCT log_file
FROM read_duck_hunt_log('test/samples/infrastructure/pf_firewall.txt', 'pf');
----
test/samples/infrastructure/pf_firewall.txt

# Clean up
statement ok
DROP TABLE rubocop_results;

statement ok
DROP TABLE cargo_results;

statement ok
DROP TABLE swiftlint_results;

statement ok
DROP TABLE phpstan_results;

statement ok
DROP TABLE shellcheck_results;

statement ok
DROP TABLE stylelint_results;

statement ok
DROP TABLE clippy_results;

statement ok
DROP TABLE markdownlint_results;

statement ok
DROP TABLE yamllint_results;

statement ok
DROP TABLE bandit_results;

statement ok
DROP TABLE spotbugs_results;

statement ok
DROP TABLE ktlint_results;

statement ok
DROP TABLE hadolint_results;

statement ok
DROP TABLE lintr_results;

statement ok
DROP TABLE sqlfluff_results;

statement ok
DROP TABLE tflint_results;

statement ok
DROP TABLE kube_score_results;

statement ok
DROP TABLE cmake_results;
# =============================================================================
# BUILD SYSTEM FORMAT TESTS - Experimental Formats
# =============================================================================

# -----------------------------------------------------------------------------
# Test 222: bazel_build - count and severity breakdown
# -----------------------------------------------------------------------------
query II
SELECT status, COUNT(*) as cnt
FROM read_duck_hunt_log('test/samples/build_systems/bazel_build_errors.txt', 'bazel_build')
GROUP BY status
ORDER BY cnt DESC, status;
----
ERROR	2
INFO	1

# -----------------------------------------------------------------------------
# Test 223: bazel_build - tool_name and category
# -----------------------------------------------------------------------------
query III
SELECT tool_name, category, COUNT(*) as cnt
FROM read_duck_hunt_log('test/samples/build_systems/bazel_build_errors.txt', 'bazel_build')
GROUP BY tool_name, category
ORDER BY cnt DESC, tool_name;
----
bazel	build_error	2
bazel	performance	1

# -----------------------------------------------------------------------------
# Test 224: bazel_build - event_type breakdown
# -----------------------------------------------------------------------------
query II
SELECT event_type, COUNT(*) as cnt
FROM read_duck_hunt_log('test/samples/build_systems/bazel_build_errors.txt', 'bazel_build')
GROUP BY event_type
ORDER BY cnt DESC, event_type;
----
build_error	2
performance_metric	1

# -----------------------------------------------------------------------------
# Test 225: bazel_build - log_file tracking
# -----------------------------------------------------------------------------
query I
SELECT DISTINCT log_file
FROM read_duck_hunt_log('test/samples/build_systems/bazel_build_errors.txt', 'bazel_build');
----
test/samples/build_systems/bazel_build_errors.txt

# -----------------------------------------------------------------------------
# Test 226: cargo_build - count and severity breakdown
# -----------------------------------------------------------------------------
query II
SELECT status, COUNT(*) as cnt
FROM read_duck_hunt_log('test/samples/build_systems/cargo_build_errors.txt', 'cargo_build')
GROUP BY status
ORDER BY cnt DESC, status;
----
ERROR	4
WARNING	1

# -----------------------------------------------------------------------------
# Test 227: cargo_build - tool_name and category
# -----------------------------------------------------------------------------
query III
SELECT tool_name, category, COUNT(*) as cnt
FROM read_duck_hunt_log('test/samples/build_systems/cargo_build_errors.txt', 'cargo_build')
GROUP BY tool_name, category
ORDER BY cnt DESC, tool_name;
----
rustc	compilation	4
cargo	compilation	1

# -----------------------------------------------------------------------------
# Test 228: cargo_build - error codes
# -----------------------------------------------------------------------------
query II
SELECT error_code, COUNT(*) as cnt
FROM read_duck_hunt_log('test/samples/build_systems/cargo_build_errors.txt', 'cargo_build')
WHERE error_code IS NOT NULL AND error_code != ''
GROUP BY error_code
ORDER BY cnt DESC, error_code;
----
E0308	1
E0382	1
E0425	1

# -----------------------------------------------------------------------------
# Test 229: cargo_build - event_type breakdown
# -----------------------------------------------------------------------------
query II
SELECT event_type, COUNT(*) as cnt
FROM read_duck_hunt_log('test/samples/build_systems/cargo_build_errors.txt', 'cargo_build')
GROUP BY event_type
ORDER BY cnt DESC, event_type;
----
build_error	4
lint_issue	1

# -----------------------------------------------------------------------------
# Test 230: cargo_build - log_file tracking
# -----------------------------------------------------------------------------
query I
SELECT DISTINCT log_file
FROM read_duck_hunt_log('test/samples/build_systems/cargo_build_errors.txt', 'cargo_build');
----
test/samples/build_systems/cargo_build_errors.txt

# -----------------------------------------------------------------------------
# Test 231: gradle_build - count and severity breakdown
# -----------------------------------------------------------------------------
query II
SELECT status, COUNT(*) as cnt
FROM read_duck_hunt_log('test/samples/build_systems/gradle_build_failures.txt', 'gradle_build')
GROUP BY status
ORDER BY cnt DESC, status;
----
ERROR	5

# -----------------------------------------------------------------------------
# Test 232: gradle_build - tool_name and category
# -----------------------------------------------------------------------------
query III
SELECT tool_name, category, COUNT(*) as cnt
FROM read_duck_hunt_log('test/samples/build_systems/gradle_build_failures.txt', 'gradle_build')
GROUP BY tool_name, category
ORDER BY cnt DESC, tool_name, category;
----
gradle-javac	compilation	2
gradle	build_result	1
gradle	execution_failure	1
gradle	task_failure	1

# -----------------------------------------------------------------------------
# Test 233: gradle_build - event_type breakdown
# -----------------------------------------------------------------------------
query II
SELECT event_type, COUNT(*) as cnt
FROM read_duck_hunt_log('test/samples/build_systems/gradle_build_failures.txt', 'gradle_build')
GROUP BY event_type
ORDER BY cnt DESC, event_type;
----
build_error	5

# -----------------------------------------------------------------------------
# Test 234: gradle_build - log_file tracking
# -----------------------------------------------------------------------------
query I
SELECT DISTINCT log_file
FROM read_duck_hunt_log('test/samples/build_systems/gradle_build_failures.txt', 'gradle_build');
----
test/samples/build_systems/gradle_build_failures.txt

# -----------------------------------------------------------------------------
# Test 235: maven_build - count and severity breakdown
# -----------------------------------------------------------------------------
query II
SELECT status, COUNT(*) as cnt
FROM read_duck_hunt_log('test/samples/build_systems/maven_build_failures.txt', 'maven_build')
GROUP BY status
ORDER BY cnt DESC, status;
----
ERROR	4
FAIL	3
WARNING	1

# -----------------------------------------------------------------------------
# Test 236: maven_build - tool_name and category
# -----------------------------------------------------------------------------
query III
SELECT tool_name, category, COUNT(*) as cnt
FROM read_duck_hunt_log('test/samples/build_systems/maven_build_failures.txt', 'maven_build')
GROUP BY tool_name, category
ORDER BY cnt DESC, tool_name, category;
----
maven-compiler	compilation	3
maven-surefire	test_summary	2
maven	build_failure	1
maven-surefire	test_error	1
maven-surefire	test_failure	1

# -----------------------------------------------------------------------------
# Test 237: maven_build - event_type breakdown
# -----------------------------------------------------------------------------
query II
SELECT event_type, COUNT(*) as cnt
FROM read_duck_hunt_log('test/samples/build_systems/maven_build_failures.txt', 'maven_build')
GROUP BY event_type
ORDER BY cnt DESC, event_type;
----
build_error	4
test_result	4

# -----------------------------------------------------------------------------
# Test 238: maven_build - log_file tracking
# -----------------------------------------------------------------------------
query I
SELECT DISTINCT log_file
FROM read_duck_hunt_log('test/samples/build_systems/maven_build_failures.txt', 'maven_build');
----
test/samples/build_systems/maven_build_failures.txt

# -----------------------------------------------------------------------------
# Test 239: msbuild - count and severity breakdown
# -----------------------------------------------------------------------------
query II
SELECT status, COUNT(*) as cnt
FROM read_duck_hunt_log('test/samples/build_systems/msbuild_errors.txt', 'msbuild')
GROUP BY status
ORDER BY cnt DESC, status;
----
ERROR	8
WARNING	3
INFO	1

# -----------------------------------------------------------------------------
# Test 240: msbuild - tool_name and category
# -----------------------------------------------------------------------------
query III
SELECT tool_name, category, COUNT(*) as cnt
FROM read_duck_hunt_log('test/samples/build_systems/msbuild_errors.txt', 'msbuild')
GROUP BY tool_name, category
ORDER BY cnt DESC, tool_name, category;
----
msbuild-csc	compilation	7
msbuild	build_result	1
msbuild	build_timing	1
msbuild	error_summary	1
msbuild	warning_summary	1
msbuild-analyzer	code_analysis	1

# -----------------------------------------------------------------------------
# Test 241: msbuild - error codes
# -----------------------------------------------------------------------------
query II
SELECT error_code, COUNT(*) as cnt
FROM read_duck_hunt_log('test/samples/build_systems/msbuild_errors.txt', 'msbuild')
WHERE error_code IS NOT NULL AND error_code != ''
GROUP BY error_code
ORDER BY cnt DESC, error_code;
----
CS0029	2
CS0246	2
CS1061	2
CA1822	1
CS0618	1

# -----------------------------------------------------------------------------
# Test 242: msbuild - log_file tracking
# -----------------------------------------------------------------------------
query I
SELECT DISTINCT log_file
FROM read_duck_hunt_log('test/samples/build_systems/msbuild_errors.txt', 'msbuild');
----
test/samples/build_systems/msbuild_errors.txt

# -----------------------------------------------------------------------------
# Test 243: node_build - count and severity breakdown
# -----------------------------------------------------------------------------
query II
SELECT status, COUNT(*) as cnt
FROM read_duck_hunt_log('test/samples/build_systems/npm_build_errors.txt', 'node_build')
GROUP BY status
ORDER BY cnt DESC, status;
----
ERROR	7
WARNING	2

# -----------------------------------------------------------------------------
# Test 244: node_build - tool_name and category
# -----------------------------------------------------------------------------
query III
SELECT tool_name, category, COUNT(*) as cnt
FROM read_duck_hunt_log('test/samples/build_systems/npm_build_errors.txt', 'node_build')
GROUP BY tool_name, category
ORDER BY cnt DESC, tool_name, category;
----
npm	package_manager	4
webpack	bundling	4
npm	dependency	1

# -----------------------------------------------------------------------------
# Test 245: node_build - event_type breakdown
# -----------------------------------------------------------------------------
query II
SELECT event_type, COUNT(*) as cnt
FROM read_duck_hunt_log('test/samples/build_systems/npm_build_errors.txt', 'node_build')
GROUP BY event_type
ORDER BY cnt DESC, event_type;
----
build_error	9

# -----------------------------------------------------------------------------
# Test 246: node_build - log_file tracking
# -----------------------------------------------------------------------------
query I
SELECT DISTINCT log_file
FROM read_duck_hunt_log('test/samples/build_systems/npm_build_errors.txt', 'node_build');
----
test/samples/build_systems/npm_build_errors.txt

# -----------------------------------------------------------------------------
# Test 247: python_build - count and severity breakdown
# -----------------------------------------------------------------------------
query II
SELECT status, COUNT(*) as cnt
FROM read_duck_hunt_log('test/samples/build_systems/pip_install_errors.txt', 'python_build')
GROUP BY status
ORDER BY cnt DESC, status;
----
ERROR	1

# -----------------------------------------------------------------------------
# Test 248: python_build - tool_name and category
# -----------------------------------------------------------------------------
query II
SELECT tool_name, category
FROM read_duck_hunt_log('test/samples/build_systems/pip_install_errors.txt', 'python_build');
----
pip	package_build

# -----------------------------------------------------------------------------
# Test 249: python_build - log_file tracking
# -----------------------------------------------------------------------------
query I
SELECT DISTINCT log_file
FROM read_duck_hunt_log('test/samples/build_systems/pip_install_errors.txt', 'python_build');
----
test/samples/build_systems/pip_install_errors.txt


# =============================================================================
# TEST FRAMEWORK FORMAT TESTS - Experimental Formats
# =============================================================================

# -----------------------------------------------------------------------------
# Test 250: gtest_text - count and severity breakdown
# -----------------------------------------------------------------------------
query II
SELECT status, COUNT(*) as cnt
FROM read_duck_hunt_log('test/samples/test_frameworks/gtest_failures.txt', 'gtest_text')
GROUP BY status
ORDER BY cnt DESC, status;
----
PASS	7
FAIL	5
INFO	1

# -----------------------------------------------------------------------------
# Test 251: gtest_text - tool_name and category
# -----------------------------------------------------------------------------
query III
SELECT tool_name, category, COUNT(*) as cnt
FROM read_duck_hunt_log('test/samples/test_frameworks/gtest_failures.txt', 'gtest_text')
GROUP BY tool_name, category
ORDER BY cnt DESC, tool_name, category;
----
gtest	gtest_text	13

# -----------------------------------------------------------------------------
# Test 252: gtest_text - failed tests
# -----------------------------------------------------------------------------
query I
SELECT TRIM(test_name)
FROM read_duck_hunt_log('test/samples/test_frameworks/gtest_failures.txt', 'gtest_text')
WHERE status = 'FAIL' AND test_name IS NOT NULL AND TRIM(test_name) != ''
ORDER BY test_name;
----
IntegrationTest.TimeoutHandling
ParserTest.ParseInvalidInput
ParserTest.ParseMalformedInput
UtilsTest.DecodeCorruptData

# -----------------------------------------------------------------------------
# Test 253: gtest_text - log_file tracking
# -----------------------------------------------------------------------------
query I
SELECT DISTINCT log_file
FROM read_duck_hunt_log('test/samples/test_frameworks/gtest_failures.txt', 'gtest_text');
----
test/samples/test_frameworks/gtest_failures.txt

# -----------------------------------------------------------------------------
# Test 254: mocha_chai_text - count and severity breakdown
# -----------------------------------------------------------------------------
query II
SELECT status, COUNT(*) as cnt
FROM read_duck_hunt_log('test/samples/test_frameworks/mocha_failures.txt', 'mocha_chai_text')
GROUP BY status
ORDER BY cnt DESC, status;
----
PASS	13
FAIL	11
INFO	1
WARNING	1

# -----------------------------------------------------------------------------
# Test 255: mocha_chai_text - tool_name and category
# -----------------------------------------------------------------------------
query II
SELECT tool_name, COUNT(*) as cnt
FROM read_duck_hunt_log('test/samples/test_frameworks/mocha_failures.txt', 'mocha_chai_text')
GROUP BY tool_name
ORDER BY cnt DESC, tool_name;
----
mocha	26

# -----------------------------------------------------------------------------
# Test 256: mocha_chai_text - event_type breakdown
# -----------------------------------------------------------------------------
query II
SELECT event_type, COUNT(*) as cnt
FROM read_duck_hunt_log('test/samples/test_frameworks/mocha_failures.txt', 'mocha_chai_text')
GROUP BY event_type
ORDER BY cnt DESC, event_type;
----
test_result	23
summary	3

# -----------------------------------------------------------------------------
# Test 257: mocha_chai_text - log_file tracking
# -----------------------------------------------------------------------------
query I
SELECT DISTINCT log_file
FROM read_duck_hunt_log('test/samples/test_frameworks/mocha_failures.txt', 'mocha_chai_text');
----
test/samples/test_frameworks/mocha_failures.txt

# -----------------------------------------------------------------------------
# Test 258: rspec_text - count and severity breakdown
# -----------------------------------------------------------------------------
query II
SELECT status, COUNT(*) as cnt
FROM read_duck_hunt_log('test/samples/test_frameworks/rspec_failures.txt', 'rspec_text')
GROUP BY status
ORDER BY cnt DESC, status;
----
PASS	11
FAIL	8
SKIP	1

# -----------------------------------------------------------------------------
# Test 259: rspec_text - category breakdown
# -----------------------------------------------------------------------------
query II
SELECT category, COUNT(*) as cnt
FROM read_duck_hunt_log('test/samples/test_frameworks/rspec_failures.txt', 'rspec_text')
GROUP BY category
ORDER BY cnt DESC, category;
----
test_success	11
test_failure	8
test_pending	1

# -----------------------------------------------------------------------------
# Test 260: rspec_text - tool_name
# -----------------------------------------------------------------------------
query II
SELECT tool_name, COUNT(*) as cnt
FROM read_duck_hunt_log('test/samples/test_frameworks/rspec_failures.txt', 'rspec_text')
GROUP BY tool_name
ORDER BY tool_name;
----
RSpec	20

# -----------------------------------------------------------------------------
# Test 261: rspec_text - log_file tracking
# -----------------------------------------------------------------------------
query I
SELECT DISTINCT log_file
FROM read_duck_hunt_log('test/samples/test_frameworks/rspec_failures.txt', 'rspec_text');
----
test/samples/test_frameworks/rspec_failures.txt


# =============================================================================
# DEBUGGING TOOL FORMAT TESTS - Experimental Formats
# =============================================================================

# -----------------------------------------------------------------------------
# Test 262: valgrind - count and severity breakdown
# -----------------------------------------------------------------------------
query II
SELECT status, COUNT(*) as cnt
FROM read_duck_hunt_log('test/samples/debugging_tools/valgrind_memcheck.txt', 'valgrind')
GROUP BY status
ORDER BY cnt DESC, status;
----
FAIL	5
INFO	2
WARNING	1

# -----------------------------------------------------------------------------
# Test 263: valgrind - tool_name and category
# -----------------------------------------------------------------------------
query III
SELECT tool_name, category, COUNT(*) as cnt
FROM read_duck_hunt_log('test/samples/debugging_tools/valgrind_memcheck.txt', 'valgrind')
GROUP BY tool_name, category
ORDER BY cnt DESC, tool_name, category;
----
Memcheck	heap_summary	2
Memcheck	leak_summary	2
Memcheck	Invalid read	1
Memcheck	Invalid write	1
Memcheck	Memory leak	1
Memcheck	error_summary	1

# -----------------------------------------------------------------------------
# Test 264: valgrind - event_type breakdown
# -----------------------------------------------------------------------------
query II
SELECT event_type, COUNT(*) as cnt
FROM read_duck_hunt_log('test/samples/debugging_tools/valgrind_memcheck.txt', 'valgrind')
GROUP BY event_type
ORDER BY cnt DESC, event_type;
----
summary	5
memory_error	3

# -----------------------------------------------------------------------------
# Test 265: valgrind - log_file tracking
# -----------------------------------------------------------------------------
query I
SELECT DISTINCT log_file
FROM read_duck_hunt_log('test/samples/debugging_tools/valgrind_memcheck.txt', 'valgrind');
----
test/samples/debugging_tools/valgrind_memcheck.txt

# -----------------------------------------------------------------------------
# Test 266: gdb_lldb - count and severity breakdown
# -----------------------------------------------------------------------------
query II
SELECT status, COUNT(*) as cnt
FROM read_duck_hunt_log('test/samples/debugging_tools/gdb_session.txt', 'gdb_lldb')
GROUP BY status
ORDER BY cnt DESC, status;
----
INFO	3
ERROR	1

# -----------------------------------------------------------------------------
# Test 267: gdb_lldb - tool_name and category
# -----------------------------------------------------------------------------
query III
SELECT tool_name, category, COUNT(*) as cnt
FROM read_duck_hunt_log('test/samples/debugging_tools/gdb_session.txt', 'gdb_lldb')
GROUP BY tool_name, category
ORDER BY cnt DESC, tool_name, category;
----
GDB	debugger_startup	1
GDB	program_start	1
GDB	signal_crash	1
GDB	watchpoint_hit	1

# -----------------------------------------------------------------------------
# Test 268: gdb_lldb - event_type breakdown
# -----------------------------------------------------------------------------
query II
SELECT event_type, COUNT(*) as cnt
FROM read_duck_hunt_log('test/samples/debugging_tools/gdb_session.txt', 'gdb_lldb')
GROUP BY event_type
ORDER BY cnt DESC, event_type;
----
debug_event	2
crash_signal	1
debug_info	1

# -----------------------------------------------------------------------------
# Test 269: gdb_lldb - log_file tracking
# -----------------------------------------------------------------------------
query I
SELECT DISTINCT log_file
FROM read_duck_hunt_log('test/samples/debugging_tools/gdb_session.txt', 'gdb_lldb');
----
test/samples/debugging_tools/gdb_session.txt


# =============================================================================
# LINTING TOOL TEXT FORMAT TESTS - Experimental Formats
# =============================================================================

# -----------------------------------------------------------------------------
# Test 270: clang_tidy_text - count and severity breakdown
# -----------------------------------------------------------------------------
query II
SELECT status, COUNT(*) as cnt
FROM read_duck_hunt_log('test/samples/linting_tools/clang_tidy_output.txt', 'clang_tidy_text')
GROUP BY status
ORDER BY cnt DESC, status;
----
WARNING	6
ERROR	3
INFO	3

# -----------------------------------------------------------------------------
# Test 271: clang_tidy_text - tool_name and category
# -----------------------------------------------------------------------------
query II
SELECT tool_name, COUNT(*) as cnt
FROM read_duck_hunt_log('test/samples/linting_tools/clang_tidy_output.txt', 'clang_tidy_text')
GROUP BY tool_name
ORDER BY tool_name;
----
clang-tidy	12

# -----------------------------------------------------------------------------
# Test 272: clang_tidy_text - error codes
# -----------------------------------------------------------------------------
query II
SELECT error_code, COUNT(*) as cnt
FROM read_duck_hunt_log('test/samples/linting_tools/clang_tidy_output.txt', 'clang_tidy_text')
WHERE error_code IS NOT NULL AND error_code != ''
GROUP BY error_code
ORDER BY cnt DESC, error_code
LIMIT 5;
----
clang-diagnostic-error	2
bugprone-narrowing-conversions	1
cppcoreguidelines-init-variables	1
misc-no-recursion	1
modernize-make-unique	1

# -----------------------------------------------------------------------------
# Test 273: clang_tidy_text - log_file tracking
# -----------------------------------------------------------------------------
query I
SELECT DISTINCT log_file
FROM read_duck_hunt_log('test/samples/linting_tools/clang_tidy_output.txt', 'clang_tidy_text');
----
test/samples/linting_tools/clang_tidy_output.txt

# -----------------------------------------------------------------------------
# Test 274: black_text - count and severity breakdown
# -----------------------------------------------------------------------------
query II
SELECT status, COUNT(*) as cnt
FROM read_duck_hunt_log('test/samples/python_tools/black_output.txt', 'black_text')
GROUP BY status
ORDER BY cnt DESC, status;
----
INFO	2
WARNING	1

# -----------------------------------------------------------------------------
# Test 275: black_text - tool_name and category
# -----------------------------------------------------------------------------
query II
SELECT tool_name, category
FROM read_duck_hunt_log('test/samples/python_tools/black_output.txt', 'black_text')
GROUP BY tool_name, category
ORDER BY tool_name;
----
black	code_formatting

# -----------------------------------------------------------------------------
# Test 276: black_text - event_type breakdown
# -----------------------------------------------------------------------------
query II
SELECT event_type, COUNT(*) as cnt
FROM read_duck_hunt_log('test/samples/python_tools/black_output.txt', 'black_text')
GROUP BY event_type
ORDER BY cnt DESC, event_type;
----
lint_issue	2
build_error	1

# -----------------------------------------------------------------------------
# Test 277: black_text - log_file tracking
# -----------------------------------------------------------------------------
query I
SELECT DISTINCT log_file
FROM read_duck_hunt_log('test/samples/python_tools/black_output.txt', 'black_text');
----
test/samples/python_tools/black_output.txt

# -----------------------------------------------------------------------------
# Test 278: flake8_text - count and severity breakdown (filter out summary)
# -----------------------------------------------------------------------------
query II
SELECT status, COUNT(*) as cnt
FROM read_duck_hunt_log('test/samples/linting_tools/flake8_output.txt', 'flake8_text')
WHERE event_type != 'summary'
GROUP BY status
ORDER BY cnt DESC, status;
----
ERROR	13
WARNING	5

# -----------------------------------------------------------------------------
# Test 279: flake8_text - tool_name and category (filter out summary)
# -----------------------------------------------------------------------------
query II
SELECT tool_name, category
FROM read_duck_hunt_log('test/samples/linting_tools/flake8_output.txt', 'flake8_text')
WHERE event_type != 'summary'
GROUP BY tool_name, category
ORDER BY tool_name;
----
flake8	style_guide

# -----------------------------------------------------------------------------
# Test 280: flake8_text - error codes sample
# -----------------------------------------------------------------------------
query II
SELECT error_code, COUNT(*) as cnt
FROM read_duck_hunt_log('test/samples/linting_tools/flake8_output.txt', 'flake8_text')
WHERE error_code IS NOT NULL AND error_code != ''
GROUP BY error_code
ORDER BY cnt DESC, error_code
LIMIT 5;
----
E501	2
F401	2
C901	1
E265	1
E302	1

# -----------------------------------------------------------------------------
# Test 281: flake8_text - log_file tracking
# -----------------------------------------------------------------------------
query I
SELECT DISTINCT log_file
FROM read_duck_hunt_log('test/samples/linting_tools/flake8_output.txt', 'flake8_text');
----
test/samples/linting_tools/flake8_output.txt

# -----------------------------------------------------------------------------
# Test 282: pylint_text - count and severity breakdown
# -----------------------------------------------------------------------------
query II
SELECT status, COUNT(*) as cnt
FROM read_duck_hunt_log('test/samples/linting_tools/pylint_output.txt', 'pylint_text')
GROUP BY status
ORDER BY cnt DESC, status;
----
INFO	10
WARNING	5
ERROR	3

# -----------------------------------------------------------------------------
# Test 283: pylint_text - tool_name and category
# -----------------------------------------------------------------------------
query II
SELECT tool_name, category
FROM read_duck_hunt_log('test/samples/linting_tools/pylint_output.txt', 'pylint_text')
GROUP BY tool_name, category
ORDER BY tool_name;
----
pylint	code_quality

# -----------------------------------------------------------------------------
# Test 284: pylint_text - error codes sample
# -----------------------------------------------------------------------------
query II
SELECT error_code, COUNT(*) as cnt
FROM read_duck_hunt_log('test/samples/linting_tools/pylint_output.txt', 'pylint_text')
WHERE error_code IS NOT NULL AND error_code != ''
GROUP BY error_code
ORDER BY cnt DESC, error_code
LIMIT 5;
----
W0612	2
C0103	1
C0114	1
C0115	1
C0116	1

# -----------------------------------------------------------------------------
# Test 285: pylint_text - log_file tracking
# -----------------------------------------------------------------------------
query I
SELECT DISTINCT log_file
FROM read_duck_hunt_log('test/samples/linting_tools/pylint_output.txt', 'pylint_text');
----
test/samples/linting_tools/pylint_output.txt


# =============================================================================
# CI SYSTEM FORMAT TESTS - Experimental Formats
# Note: CI formats use read_duck_hunt_workflow_log, not read_duck_hunt_log
# =============================================================================

# -----------------------------------------------------------------------------
# Test 286: github_actions - count and severity breakdown
# -----------------------------------------------------------------------------
query II
SELECT status, COUNT(*) as cnt
FROM read_duck_hunt_workflow_log('test/samples/ci_systems/github_actions_workflow.txt', 'github_actions')
GROUP BY status
ORDER BY cnt DESC, status;
----
INFO	48
PASS	3
ERROR	1
WARNING	1

# -----------------------------------------------------------------------------
# Test 287: github_actions - tool_name and category
# -----------------------------------------------------------------------------
query II
SELECT tool_name, category
FROM read_duck_hunt_workflow_log('test/samples/ci_systems/github_actions_workflow.txt', 'github_actions')
GROUP BY tool_name, category
ORDER BY tool_name;
----
github_actions	workflow

# -----------------------------------------------------------------------------
# Test 288: github_actions - workflow structure (steps)
# -----------------------------------------------------------------------------
query II
SELECT unit, COUNT(*) as cnt
FROM read_duck_hunt_workflow_log('test/samples/ci_systems/github_actions_workflow.txt', 'github_actions')
WHERE unit IS NOT NULL AND unit != ''
GROUP BY unit
ORDER BY cnt DESC, unit
LIMIT 5;
----
Run npm test	17
Run actions/checkout@v4	11
Run npm run lint	7
Annotations	6
Run actions/setup-node@v4	6

# -----------------------------------------------------------------------------
# Test 289: github_actions - verify file parsing works
# -----------------------------------------------------------------------------
query I
SELECT COUNT(*) >= 1 as has_events
FROM read_duck_hunt_workflow_log('test/samples/ci_systems/github_actions_workflow.txt', 'github_actions');
----
true

# -----------------------------------------------------------------------------
# Test 290: gitlab_ci - count and severity breakdown
# -----------------------------------------------------------------------------
query II
SELECT status, COUNT(*) as cnt
FROM read_duck_hunt_workflow_log('test/samples/ci_systems/gitlab_ci_output.txt', 'gitlab_ci')
GROUP BY status
ORDER BY cnt DESC, status;
----
INFO	52

# -----------------------------------------------------------------------------
# Test 291: gitlab_ci - tool_name
# -----------------------------------------------------------------------------
query II
SELECT tool_name, COUNT(*) as cnt
FROM read_duck_hunt_workflow_log('test/samples/ci_systems/gitlab_ci_output.txt', 'gitlab_ci')
GROUP BY tool_name
ORDER BY tool_name;
----
gitlab_ci	52

# -----------------------------------------------------------------------------
# Test 292: gitlab_ci - verify file parsing works
# -----------------------------------------------------------------------------
query I
SELECT COUNT(*) >= 1 as has_events
FROM read_duck_hunt_workflow_log('test/samples/ci_systems/gitlab_ci_output.txt', 'gitlab_ci');
----
true

# -----------------------------------------------------------------------------
# Test 293: jenkins - count and severity breakdown
# -----------------------------------------------------------------------------
query II
SELECT status, COUNT(*) as cnt
FROM read_duck_hunt_workflow_log('test/samples/ci_systems/jenkins_console_output.txt', 'jenkins')
GROUP BY status
ORDER BY cnt DESC, status;
----
INFO	68

# -----------------------------------------------------------------------------
# Test 294: jenkins - tool_name
# -----------------------------------------------------------------------------
query II
SELECT tool_name, COUNT(*) as cnt
FROM read_duck_hunt_workflow_log('test/samples/ci_systems/jenkins_console_output.txt', 'jenkins')
GROUP BY tool_name
ORDER BY tool_name;
----
jenkins	68

# -----------------------------------------------------------------------------
# Test 295: jenkins - verify file parsing works
# -----------------------------------------------------------------------------
query I
SELECT COUNT(*) >= 1 as has_events
FROM read_duck_hunt_workflow_log('test/samples/ci_systems/jenkins_console_output.txt', 'jenkins');
----
true


# =============================================================================
# SECURITY SCANNER FORMAT TESTS - Experimental Formats
# =============================================================================

# -----------------------------------------------------------------------------
# Test 296: trivy_json - count and severity breakdown
# -----------------------------------------------------------------------------
query II
SELECT status, COUNT(*) as cnt
FROM read_duck_hunt_log('test/samples/security_tools/trivy_scan.json', 'trivy_json')
GROUP BY status
ORDER BY cnt DESC, status;
----
ERROR	4
WARNING	1

# -----------------------------------------------------------------------------
# Test 297: trivy_json - tool_name and category
# -----------------------------------------------------------------------------
query III
SELECT tool_name, category, COUNT(*) as cnt
FROM read_duck_hunt_log('test/samples/security_tools/trivy_scan.json', 'trivy_json')
GROUP BY tool_name, category
ORDER BY cnt DESC, tool_name, category;
----
trivy	vulnerability	4
trivy	misconfiguration	1

# -----------------------------------------------------------------------------
# Test 298: trivy_json - severity breakdown
# -----------------------------------------------------------------------------
query II
SELECT severity, COUNT(*) as cnt
FROM read_duck_hunt_log('test/samples/security_tools/trivy_scan.json', 'trivy_json')
GROUP BY severity
ORDER BY cnt DESC, severity;
----
HIGH	3
CRITICAL	1
MEDIUM	1

# -----------------------------------------------------------------------------
# Test 299: trivy_json - log_file tracking
# -----------------------------------------------------------------------------
query I
SELECT DISTINCT log_file
FROM read_duck_hunt_log('test/samples/security_tools/trivy_scan.json', 'trivy_json');
----
test/samples/security_tools/trivy_scan.json

# -----------------------------------------------------------------------------
# Test 300: tfsec_json - count and severity breakdown
# -----------------------------------------------------------------------------
query II
SELECT status, COUNT(*) as cnt
FROM read_duck_hunt_log('test/samples/security_tools/tfsec_scan.json', 'tfsec_json')
GROUP BY status
ORDER BY cnt DESC, status;
----
ERROR	3
WARNING	1

# -----------------------------------------------------------------------------
# Test 301: tfsec_json - tool_name and category
# -----------------------------------------------------------------------------
query II
SELECT tool_name, category
FROM read_duck_hunt_log('test/samples/security_tools/tfsec_scan.json', 'tfsec_json')
GROUP BY tool_name, category
ORDER BY tool_name;
----
tfsec	infrastructure_security

# -----------------------------------------------------------------------------
# Test 302: tfsec_json - severity breakdown
# -----------------------------------------------------------------------------
query II
SELECT severity, COUNT(*) as cnt
FROM read_duck_hunt_log('test/samples/security_tools/tfsec_scan.json', 'tfsec_json')
GROUP BY severity
ORDER BY cnt DESC, severity;
----
HIGH	2
CRITICAL	1
MEDIUM	1

# -----------------------------------------------------------------------------
# Test 303: tfsec_json - log_file tracking
# -----------------------------------------------------------------------------
query I
SELECT DISTINCT log_file
FROM read_duck_hunt_log('test/samples/security_tools/tfsec_scan.json', 'tfsec_json');
----
test/samples/security_tools/tfsec_scan.json

# =============================================================================
# INFRASTRUCTURE FORMAT TESTS - Additional Experimental Formats
# =============================================================================

# -----------------------------------------------------------------------------
# Test 304: s3_access - count and severity breakdown
# -----------------------------------------------------------------------------
query II
SELECT status, COUNT(*) as cnt
FROM read_duck_hunt_log('test/samples/infrastructure/s3_access_logs.txt', 's3_access')
GROUP BY status
ORDER BY cnt DESC, status;
----
INFO	6
WARNING	2
ERROR	1

# -----------------------------------------------------------------------------
# Test 305: s3_access - tool_name
# -----------------------------------------------------------------------------
query II
SELECT tool_name, COUNT(*) as cnt
FROM read_duck_hunt_log('test/samples/infrastructure/s3_access_logs.txt', 's3_access')
GROUP BY tool_name
ORDER BY tool_name;
----
s3_access	9

# -----------------------------------------------------------------------------
# Test 306: s3_access - log_file tracking
# -----------------------------------------------------------------------------
query I
SELECT DISTINCT log_file
FROM read_duck_hunt_log('test/samples/infrastructure/s3_access_logs.txt', 's3_access');
----
test/samples/infrastructure/s3_access_logs.txt

